<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>江科大32study | Shenle</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="article">
<meta property="og:title" content="江科大32study">
<meta property="og:url" content="https://github.com/2575451471/2575451471.github.io/2025/01/03/%E6%B1%9F%E7%A7%91%E5%A4%A732study.18635848/index.html">
<meta property="og:site_name" content="Shenle">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200331104604928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200331104632916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200331104653733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151326808-2058574554.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151359881-219129173.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151420523-1403874113.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151450133-1493062396.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151459179-1724320527.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151507862-159193175.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151517146-843466406.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151526936-1719038981.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151539107-2003748964.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151603591-1564314662.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151653968-1250563888.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151715029-461089462.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151728077-865793877.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151749768-670230649.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151804922-562307058.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151817180-1832999758.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151841380-1286538001.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151854223-515763241.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151914707-1323509025.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151928655-2054898411.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152006599-1737193749.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152019354-1404291025.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152035785-11546224.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152114391-1064811219.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152134614-1909809547.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152147599-1931023227.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152212171-2076256006.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152223980-112883284.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152237797-476936291.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152247652-456208791.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152310595-1774164142.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152323022-1596337104.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152344501-1945178892.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152357292-1536704779.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152420039-1688714122.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152436710-1228942409.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152446466-1877468206.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152457364-1970908243.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152509396-1398290698.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152520572-575444862.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152544908-733690955.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152555993-136125364.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152605263-220342738.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152620162-1746006097.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152631192-1845598711.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152650767-56308995.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152705281-527784735.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152751095-1984011113.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152808687-1443820486.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152821392-350369421.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152834957-1243177261.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152851807-771942128.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152903237-481632599.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152914129-214173516.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152924738-44723044.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152935506-1428393607.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152944661-1685694101.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152956089-1849137041.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153008878-656879406.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153018864-694605011.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153028273-233877776.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153042426-1771192404.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153107673-1054938073.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153117105-709086754.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153136737-1361256815.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153147032-1300066630.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153200836-1069005820.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153211966-1388821852.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153221419-236176009.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-3cd27f205f9c07fde754986ac78ec643_720w.webp">
<meta property="article:published_time" content="2025-01-03T15:38:00.000Z">
<meta property="article:modified_time" content="2025-02-14T20:26:54.409Z">
<meta property="article:author" content="shenle">
<meta property="article:tag" content="嵌入式32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200331104604928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70">
  
    <link rel="alternative" href="/atom.xml" title="Shenle" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>

<script src="/js/Counter.js"></script>

  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/header.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">shenle</a></h1>
		</hgroup>

		
			<p class="header-subtitle"></p>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
					        
								<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
					        
								<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=1941325363&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">上课笔记</a> <a href="/tags/%E5%B0%8F%E8%AE%B0/" style="font-size: 15px;">小记</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F32/" style="font-size: 15px;">嵌入式32</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F51/" style="font-size: 10px;">嵌入式51</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8Fti/" style="font-size: 10px;">嵌入式ti</a> <a href="/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B/" style="font-size: 10px;">智能车竞赛</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 20px;">编程语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">噜啦啦!</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/header.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
			        
						<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
			        
						<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-江科大32study.18635848" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/03/%E6%B1%9F%E7%A7%91%E5%A4%A732study.18635848/" class="article-date">
  	<time datetime="2025-01-03T15:38:00.000Z" itemprop="datePublished">2025-01-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      江科大32study
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F32/" rel="tag">嵌入式32</a></li></ul>
	</div>

        

        
          
<div class="counter-tag counter">
    <span id="/2025/01/03/%E6%B1%9F%E7%A7%91%E5%A4%A732study.18635848/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="江科大32study">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <meta name="referrer" content="no-referrer"/>
<span id="more"></span>




<h1 id="江科大自化协（stm32）"><a href="#江科大自化协（stm32）" class="headerlink" title="江科大自化协（stm32）"></a>江科大自化协（stm32）</h1><h2 id="STM32F103RCT6产品参数"><a href="#STM32F103RCT6产品参数" class="headerlink" title="STM32F103RCT6产品参数"></a>STM32F103RCT6产品参数</h2><table>
<thead>
<tr>
<th><strong>产品型号</strong></th>
<th><strong>内核</strong></th>
<th><strong>主频（MHz）</strong></th>
<th><strong>Flash (Kbytes)</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>STM32F103RCT6</td>
<td>Cortex-M3</td>
<td>72</td>
<td>256</td>
<td></td>
</tr>
<tr>
<td><strong>RAM（Kbytes）</strong></td>
<td><strong>E2PROM（Bytes）</strong></td>
<td><strong>封装</strong></td>
<td><strong>IO</strong></td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>LQFP64</td>
<td>51</td>
<td></td>
</tr>
<tr>
<td><strong>工作电压</strong></td>
<td><strong>16位定时器</strong></td>
<td><strong>32位定时器</strong></td>
<td><strong>电机控制定时器 (16-bit)</strong></td>
<td></td>
</tr>
<tr>
<td>2-3.6</td>
<td>8</td>
<td>0</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><strong>低功耗定时器</strong></td>
<td><strong>高分辨率定时器</strong></td>
<td><strong>12位ADC转换单元</strong></td>
<td><strong>12位ADC通道</strong></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>3</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td><strong>14位ADC转换单元</strong></td>
<td><strong>14位ADC通道</strong></td>
<td><strong>16位ADC转换单元</strong></td>
<td><strong>16位ADC通道</strong></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td><strong>12位DAC通道</strong></td>
<td><strong>比较器</strong></td>
<td><strong>放大器</strong></td>
<td><strong>SPI</strong></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td><strong>I2S</strong></td>
<td><strong>M-SPI</strong></td>
<td><strong>I2C</strong></td>
<td><strong>U(S)ART</strong></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td><strong>低功耗UART</strong></td>
<td><strong>CAN</strong></td>
<td><strong>SDIO</strong></td>
<td><strong>F（S）MC</strong></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td><strong>USB Device</strong></td>
<td><strong>USB FS HOST&#x2F;OTG</strong></td>
<td><strong>USB HS OTG</strong></td>
<td><strong>Ethernet</strong></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td><strong>MDIO</strong></td>
<td><strong>Segment LCD</strong></td>
<td><strong>JPEG Codec</strong></td>
<td><strong>GPU</strong></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
<tr>
<td><strong>3D GPU</strong></td>
<td><strong>TFT LCD</strong></td>
<td><strong>MIPI_DSI</strong></td>
<td><strong>SAI</strong></td>
<td></td>
</tr>
<tr>
<td>N&#x2F;A</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td><strong>SPDIFRX</strong></td>
<td><strong>DFSDM</strong></td>
<td><strong>DCMI</strong></td>
<td><strong>SWPMI</strong></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td><strong>Math Accelerator</strong></td>
<td><strong>RF</strong></td>
<td><strong>Trust’Zone</strong></td>
<td><strong>TRNG</strong></td>
<td></td>
</tr>
<tr>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
<tr>
<td><strong>OTFDEC</strong></td>
<td><strong>PKA</strong></td>
<td><strong>AES&#x2F;DES</strong></td>
<td><strong>SHA&#x2F;HMAC</strong></td>
<td></td>
</tr>
<tr>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td></td>
</tr>
<tr>
<td><strong>T° Max(℃)</strong></td>
<td><strong>URL</strong></td>
<td><strong>content</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>85</td>
<td><a target="_blank" rel="noopener" href="https://www.st.com/en/product/STM32F103RC">https://www.st.com/en/product/STM32F103RC</a></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="STM32F103RCT6引脚定义"><a href="#STM32F103RCT6引脚定义" class="headerlink" title="STM32F103RCT6引脚定义 "></a>STM32F103RCT6引脚定义 <img src="https://img-blog.csdnimg.cn/20200331104604928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70" alt="img"></h2><p> <img src="https://img-blog.csdnimg.cn/20200331104632916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200331104653733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxNjUzMzUw,size_16,color_FFFFFF,t_70" alt="img"> </p>
<h2 id="输入输出形式：GPIO的八种工作模式"><a href="#输入输出形式：GPIO的八种工作模式" class="headerlink" title="输入输出形式：GPIO的八种工作模式"></a>输入输出形式：GPIO的八种工作模式</h2><table>
<thead>
<tr>
<th><strong>模式名称</strong></th>
<th><strong>性质</strong></th>
<th><strong>特征</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IN_FLOATING浮空输入</td>
<td>数字输入</td>
<td>可读取引脚电平，若引脚悬空，则电平不确定</td>
</tr>
<tr>
<td>IPU上拉输入</td>
<td>数字输入</td>
<td>可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td>
</tr>
<tr>
<td>IPD下拉输入</td>
<td>数字输入</td>
<td>可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td>
</tr>
<tr>
<td>AIN模拟输入</td>
<td>模拟输入</td>
<td>GPIO无效，引脚直接接入内部ADC</td>
</tr>
<tr>
<td>Out_OD开漏输出</td>
<td>数字输出</td>
<td>可输出引脚电平，高电平为高阻态，低电平接VSS</td>
</tr>
<tr>
<td>Out_PP推挽输出</td>
<td>数字输出</td>
<td>可输出引脚电平，高电平接VDD，低电平接VSS</td>
</tr>
<tr>
<td>AF_OD复用开漏输出</td>
<td>数字输出</td>
<td>由片上外设控制，高电平为高阻态，低电平接VSS</td>
</tr>
<tr>
<td>AF_PP复用推挽输出</td>
<td>数字输出</td>
<td>由片上外设控制，高电平接VDD，低电平接VSS</td>
</tr>
</tbody></table>
<h5 id="推挽输出Out-PP与开漏输出Out-OD"><a href="#推挽输出Out-PP与开漏输出Out-OD" class="headerlink" title="推挽输出Out_PP与开漏输出Out_OD:"></a>推挽输出Out_PP与开漏输出Out_OD:</h5><p>推挽输出高低电平均有驱动能力.</p>
<p>开漏输出高电平相当于高阻态，没有驱动能力，低电平有驱动能力.</p>
<p>（一般输出用推挽就行，特殊采用开漏）</p>
<h5 id="VCC-VDD-VSS"><a href="#VCC-VDD-VSS" class="headerlink" title="VCC,VDD,VSS:"></a>VCC,VDD,VSS:</h5><p>电压的作用对象不同：VCC的供电电压作用于电路。VDD的工作电压作用于芯片。VSS的电压作用于器件内部。</p>
<p> 来源不同：VDD来源于漏极电源电压，用于 MOS 晶体管电路, 一般指正电源。  Vss来源于极电源电压，在 CMOS 电路中指负电源, 在单电源时指零伏或接地。 </p>
<h5 id="GPIO以及AFIO各个函数："><a href="#GPIO以及AFIO各个函数：" class="headerlink" title="GPIO以及AFIO各个函数："></a>GPIO以及AFIO各个函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;<span class="comment">//对GPIOX进行复位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//AFIO外设复位，清除其配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;<span class="comment">//IO引脚的初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO的四个读取函数</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//读取输入数据寄存器某一个端口的输入值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;<span class="comment">//读取整个输入数据寄存器的，返回值16位，每一位代表一个端口值</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//读取输出数据寄存器的某一个位（一般用于输出模式，看一下自己输出了什么）</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;<span class="comment">//读取整个输出寄存器</span></span><br><span class="line"><span class="comment">//GPIO的四个读取函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//把指定的端口设置为高电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//把指定的端口设置为低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;<span class="comment">//前两个参数指定端口，根据第三个参数的值设定指定端口，Bit_RESET清除端口引脚，置低电平，Bit_SET设置端口引脚，置高电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;<span class="comment">//“portval”可以同时对16个端口进行写入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//锁定GPIO某个引脚的（用的不多）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;<span class="comment">//配置AFIO的事件输出功能（用的不多）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//配置AFIO的事件输出功能（用的不多）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span>;<span class="comment">//可以用来引脚重映射（重映射的方式，新的状态）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;<span class="comment">//配置AFIO的数据选择器，选择我们想要的中断引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ETH_MediaInterfaceConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_ETH_MediaInterface)</span>;<span class="comment">//与以太网有关，暂时用不到</span></span><br></pre></td></tr></table></figure>



<h2 id="stm新建工程启动文件后缀意义"><a href="#stm新建工程启动文件后缀意义" class="headerlink" title="stm新建工程启动文件后缀意义"></a>stm新建工程启动文件后缀意义</h2><p>（stm32F103RCT6的容量是256kb）</p>
<table>
<thead>
<tr>
<th><strong>缩写</strong></th>
<th><strong>释义</strong></th>
<th><strong>Flash****容量</strong></th>
<th><strong>型号</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LD_VL</td>
<td>小容量产品超值系列</td>
<td>16~32K</td>
<td>STM32F100</td>
</tr>
<tr>
<td>MD_VL</td>
<td>中容量产品超值系列</td>
<td>64~128K</td>
<td>STM32F100</td>
</tr>
<tr>
<td>HD_VL</td>
<td>大容量产品超值系列</td>
<td>256~512K</td>
<td>STM32F100</td>
</tr>
<tr>
<td>LD</td>
<td>小容量产品</td>
<td>16~32K</td>
<td>STM32F101&#x2F;102&#x2F;103</td>
</tr>
<tr>
<td>MD</td>
<td>中容量产品</td>
<td>64~128K</td>
<td>STM32F101&#x2F;102&#x2F;103</td>
</tr>
<tr>
<td>HD</td>
<td>大容量产品</td>
<td>256~512K</td>
<td>STM32F101&#x2F;102&#x2F;103</td>
</tr>
<tr>
<td>XL</td>
<td>加大容量产品</td>
<td>大于512K</td>
<td>STM32F101&#x2F;102&#x2F;103</td>
</tr>
<tr>
<td>CL</td>
<td>互联型产品</td>
<td>-</td>
<td>STM32F105&#x2F;107</td>
</tr>
</tbody></table>
<h2 id="LED-蜂鸣器，按键电路图示"><a href="#LED-蜂鸣器，按键电路图示" class="headerlink" title="LED,蜂鸣器，按键电路图示"></a>LED,蜂鸣器，按键电路图示</h2><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151326808-2058574554.png" alt="img"></p>
<p>STM32低电平点亮LED灯。低电平强驱动<br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151359881-219129173.png" alt="img"><br>STM32高电平点亮LED灯。高电平弱驱动</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151420523-1403874113.png" alt="img"></p>
<p>PNP三极管驱动电路（左边是基极，带箭头的是发射极，剩下的是集电极）（左边基极给低电平，三极管就会导通，通过3.3v和GND，就可以给蜂鸣器提供驱动电流，反之基极给高电平，截止，没有电流）(PNP三极管最好接上边，这是因为三极管的通断是需要在发射极和基极直接产生一定的开启电压 )<br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151450133-1493062396.png" alt="img"></p>
<p>NPN三极管驱动电路（左边是基极，带箭头的是发射极，剩下的是集电极）（基极给高电平导通，低电平断开）（NPN三极管最好接下边， 这是因为三极管的通断是需要在发射极和基极直接产生一定的开启电压 ）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151459179-1724320527.png" alt="img"></p>
<p>按键图示（PA0内部必须是上拉输入模式，则此时按键松开引脚悬空输入的是高电平，按下按键连接GND以致PA是低电平）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151507862-159193175.png" alt="img"></p>
<p>按键图示（已经存在上拉电阻，PA0可以是上拉输入（内外上拉电阻共同作用）也可以是浮空输入）按下为低电平，松开为高电平</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151517146-843466406.png" alt="img"></p>
<p>（拓展，不常用）按键图示（下拉输入，不可浮空输入）按下是高电平，松开是低电平</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151526936-1719038981.png" alt="img"><br>（拓展，不常用）按键图示（下拉输入或者浮空输入）按下是高电平，松开是低电平</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151539107-2003748964.png" alt="img"></p>
<p>传感器模块电路图示：DO数字输出，AO模拟输出</p>
<h2 id="OLED文件提供："><a href="#OLED文件提供：" class="headerlink" title="OLED文件提供："></a>OLED文件提供：</h2><p>引脚配置与引脚初始化需要按照实际板子样式配置，其余不需要更改。</p>
<p>OLED显示屏总共4行16列（1行一列开头，无0行0列）</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OLED_Init();</td>
<td>初始化</td>
</tr>
<tr>
<td>OLED_Clear();</td>
<td>清屏</td>
</tr>
<tr>
<td>OLED_ShowChar(1, 1, ‘A’);</td>
<td>显示一个字符</td>
</tr>
<tr>
<td>OLED_ShowString(1, 3, “HelloWorld!”);</td>
<td>显示字符串</td>
</tr>
<tr>
<td>OLED_ShowNum(2, 1, 12345, 5);</td>
<td>显示十进制数字</td>
</tr>
<tr>
<td>OLED_ShowSignedNum(2, 7, -66, 2);</td>
<td>显示有符号十进制数字</td>
</tr>
<tr>
<td>OLED_ShowHexNum(3, 1, 0xAA55, 4);</td>
<td>显示十六进制数字</td>
</tr>
<tr>
<td>OLED_ShowBinNum(4, 1, 0xAA55, 16);</td>
<td>显示二进制数字</td>
</tr>
</tbody></table>
<p>（上表第四个数字为长度）（C语言不能直接写二进制的数）</p>
<h2 id="C语言知识拓展"><a href="#C语言知识拓展" class="headerlink" title="C语言知识拓展"></a>C语言知识拓展</h2><h3 id="C语言数字类型"><a href="#C语言数字类型" class="headerlink" title="C语言数字类型"></a>C语言数字类型</h3><p>（“int”数据在51单片机中占16位，在STM32中占32位）（32想表示16位的数据得用“short”）(stdint.h头文件与ST库函数对这些变量的重命名)</p>
<table>
<thead>
<tr>
<th><strong>关键字</strong></th>
<th><strong>位数</strong></th>
<th><strong>表示范围</strong></th>
<th><strong>stdint****关键字</strong></th>
<th><strong>ST****关键字</strong></th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>8</td>
<td>-128 ~ 127</td>
<td>int8_t</td>
<td>s8</td>
</tr>
<tr>
<td>unsigned char</td>
<td>8</td>
<td>0 ~ 255</td>
<td>uint8_t</td>
<td>u8</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768 ~ 32767</td>
<td>int16_t</td>
<td>s16</td>
</tr>
<tr>
<td>unsigned short</td>
<td>16</td>
<td>0 ~ 65535</td>
<td>uint16_t</td>
<td>u16</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2147483648 ~ 2147483647</td>
<td>int32_t</td>
<td>s32</td>
</tr>
<tr>
<td>unsigned int</td>
<td>32</td>
<td>0 ~ 4294967295</td>
<td>uint32_t</td>
<td>u32</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td>-2147483648 ~ 2147483647</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long</td>
<td>32</td>
<td>0 ~ 4294967295</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>-(2^64)&#x2F;2 ~ (2^64)&#x2F;2-1</td>
<td>int64_t</td>
<td></td>
</tr>
<tr>
<td>unsigned long long</td>
<td>64</td>
<td>0 ~ (2^64)-1</td>
<td>uint64_t</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>-3.4e38 ~ 3.4e38</td>
<td></td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>-1.7e308 ~ 1.7e308</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>extern （外部变量，跨越工程下的不同文件）</p>
<h3 id="typedef-define-结构体，枚举"><a href="#typedef-define-结构体，枚举" class="headerlink" title="typedef,define,结构体，枚举"></a>typedef,define,结构体，枚举</h3><p>结构体eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StructName.z = <span class="number">1.23</span>;<span class="comment">//结构体变量名.结构体成员名</span></span><br><span class="line">pStructName-&gt;z = <span class="number">1.23</span>;<span class="comment">//结构体指针名-&gt;结构体成员名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举：关键字：enum<br>用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合<br>定义枚举变量：enum{FALSE &#x3D; 0, TRUE &#x3D; 1} EnumName;<br>因为枚举变量类型较长，所以通常用typedef更改变量类型名<br>引用枚举成员：<br>EnumName &#x3D; FALSE;<br>EnumName &#x3D; TRUE;</p>
<p>enum{MONDAY&#x3D;0,TUSDAY,WEDNESDAY}week;&#x2F;&#x2F;后面的值可不赋，系统自动按顺序赋值0，1，2，3，4~~~</p>
<h2 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a>STM32中断</h2><p>68个可屏蔽中断通道，包含EXTI（外部中断）、TIM（定时中断）、ADC（模数转换器）、USART（串口）、SPI（通信）、I2C（通信）、RTC（实时时钟）等多个外设</p>
<p>使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级（NVIC是用来管理中断，分配16个优先级的）</p>
<h3 id="中断函数模块示例"><a href="#中断函数模块示例" class="headerlink" title="中断函数模块示例"></a>中断函数模块示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;<span class="comment">//全局变量默认是0（用于记录中断的次数）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//配置外部中断</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//第一步：把涉及的外设时钟都打开-&gt;配置RCC（不打开时钟，外设是没法工作的）</span></span><br><span class="line">	<span class="comment">//第二步：配置GPIO,选择我们的端口为输入模式</span></span><br><span class="line">	<span class="comment">//第三步：配置AFIO,选择我们用的这一路的GPIO，连接到后面的EXTI</span></span><br><span class="line">	<span class="comment">//第四步：配置EXTI,选择边缘触发方式（上升沿，下降沿，双边沿），选择触发响应方式（中断响应，事件响应）</span></span><br><span class="line">	<span class="comment">//第五步：配置NVIC，给这个中断选择一个合适的优先级-&gt;通过NVIC，外部中断信号就能进入CPU了，CPU才能跳转到中断函数执行中断程序</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第一步：</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<span class="comment">//开启外部时钟GPIOB(GPIOB是APB2的外设)</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启AFIO时钟（AFIO也是APB2的外设）</span></span><br><span class="line">    <span class="comment">//EXTI与NVIC的外设是一直打开着的，不需要我们再开启（NVIC是内核外设，不需要开启时钟，和CPU一起住皇宫里的）</span></span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二步：</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入，默认为高电平的输入方式(对于外部中断来说，要选择浮空输入，上拉输入或者下拉输入。)</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;<span class="comment">//PB14号口</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//速度</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<span class="comment">//初始化GPIOB外设</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三步</span></span><br><span class="line">	<span class="comment">//AFIO外设没有专门的库函数文件，他的库函数是与GPIO一起的</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);<span class="comment">//连接PB14号口的第14个中断线路</span></span><br><span class="line">	<span class="comment">//AFIO外部的中断引脚选择配置完成，执行完上面这个函数后，AFIO的第14个数据选择器就拨好了，其中输入端被拨到了GPIOB,对应的就是PB14号引脚，输出端固定连接的是EXTI的第14个中断线路</span></span><br><span class="line">	<span class="comment">//如此，PB14号引脚的电平信号就可以顺利通过AFIO，进入到后级EXTI电路了</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第四步：将EXTI的第14号线路配置为中断模式，下降沿触发，开启中断</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义结构体</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Line=EXTI_Line14 ;<span class="comment">//指定我们要配置的中断线-&gt;PB14所在的第十四号线路</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//指定选择的中断线的新状态（开启中断或关闭中断）</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//指定外部中断线的模式（中断模式，事件模式）</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling ;<span class="comment">//指定触发信号的有效边沿（上升沿，下降沿，双边沿）</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//外部中断初始化</span></span><br><span class="line">	<span class="comment">//如此，PB14的电平信号就能通过EXTI进入下一级NVIC了</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第五步</span></span><br><span class="line">	 NVIC_PriorityGroupConfig( NVIC_PriorityGroup_2);<span class="comment">//中断分组方式-&gt;抢占2，响应2</span></span><br><span class="line">	 NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义结构体</span></span><br><span class="line">	 NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn;<span class="comment">//指定中断通道来开启或者关闭</span></span><br><span class="line">	 NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<span class="comment">//中断通道是使能还是失能</span></span><br><span class="line">	 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//指定所选通道的抢占优先级</span></span><br><span class="line">	 NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//指定所选通道的响应优先级</span></span><br><span class="line">	 NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">//外部中断的信号从GPIO到AFIO再到EXTI再到NVIC最后通向CPU,让CPU从主程序跳转到中断程序执行</span></span><br><span class="line">	 <span class="comment">//STM32中，中断函数的名字都是固定的，每个中断通道对应一个中断函数（去启动文件找中断函数的名字）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//中断函数的格式（启动文件中找中断函数的固定名字）（中断函数都是无参无返回值的）(中断函数无需在.h文件中声明)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line14)==SET)<span class="comment">//先进行一个中断标志位的判断（因为这个函数EXTI10到EXTI15都能进来，需要判断是不是EXTI14进来）</span></span><br><span class="line">	&#123;</span><br><span class="line">		CountSensor_Count++;<span class="comment">//用于记录中断的次数</span></span><br><span class="line">		</span><br><span class="line">		 EXTI_ClearITPendingBit(EXTI_Line14);<span class="comment">//中断函数结束后，调用一下清除中断标志位的函数（只要中断标志位置1，就会跳转到中断函数）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Count_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//返回记录中断的变量值CountSensor_Count</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NVIC基本结构"><a href="#NVIC基本结构" class="headerlink" title="NVIC基本结构"></a>NVIC基本结构</h3><p>（NVIC是一个内核外设，是CPU的小助手）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151603591-1564314662.png" alt="img"></p>
<h3 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h3><p>NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级<br>抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p>
<table>
<thead>
<tr>
<th><strong>分组方式</strong></th>
<th><strong>抢占优先级</strong></th>
<th align="left"><strong>响应优先级</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分组0</td>
<td>0位，取值为0</td>
<td align="left">4位，取值为0~15</td>
</tr>
<tr>
<td>分组1</td>
<td>1位，取值为0~1</td>
<td align="left">3位，取值为0~7</td>
</tr>
<tr>
<td>分组2</td>
<td>2位，取值为0~3</td>
<td align="left">2位，取值为0~3</td>
</tr>
<tr>
<td>分组3</td>
<td>3位，取值为0~7</td>
<td align="left">1位，取值为0~1</td>
</tr>
<tr>
<td>分组4</td>
<td>4位，取值为0~15</td>
<td align="left">0位，取值为0</td>
</tr>
</tbody></table>
<h3 id="NVIC函数"><a href="#NVIC函数" class="headerlink" title="NVIC函数"></a>NVIC函数</h3><p>（在中断配置之前，先指定一下中断的分组，再初始化NVIC）（分组的方式整个芯片只能用一种，分组的代码整个工程只需要执行一次）（如果把它放在模块里进行分组，要保证每个模块分组都选的是同一个，或者把这个代码放在主函数的最开始，这样模块里就不用再进行分组了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;<span class="comment">//用于中断分组（参数是中断分组的方式）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span>;<span class="comment">//根据结构体里面指定的参数初始化NVIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SetVectorTable</span><span class="params">(<span class="type">uint32_t</span> NVIC_VectTab, <span class="type">uint32_t</span> Offset)</span>;<span class="comment">//设置中断向量表（用的不多）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SystemLPConfig</span><span class="params">(<span class="type">uint8_t</span> LowPowerMode, FunctionalState NewState)</span>;<span class="comment">//系统低功耗配置（用的不多）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_CLKSourceConfig</span><span class="params">(<span class="type">uint32_t</span> SysTick_CLKSource)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="中断详情"><a href="#中断详情" class="headerlink" title="中断详情"></a>中断详情</h3><p>灰色部分：内核的中断（比较高深，一般用不到）</p>
<p>白色部分：STM32外设的中断</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151653968-1250563888.png" alt="img"></p>
<p>WWDG(窗口定时器中断：窗口看门狗)</p>
<h3 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h3><p>EXTI（Extern Interrupt）外部中断<br>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序<br>支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发（引脚啥事没有，程序里一句代码就能执行中断）<br>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断（eg.PA0与PB0不能同时用）（后面四个其实是来外部中断蹭网的，因为外部中断能从低功耗模式的停止模式下唤醒STM32）<br>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒（总共20个中断线路）<br>触发响应方式：中断响应（申请中断，让CPU执行中断）&#x2F;事件响应（当外部中断检测到引脚电平变化时，选择触发事件，外部中断的信号就不会通向CPU了而是通向·触发其他外设(属于外设之间的联合操作)）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151715029-461089462.png" alt="img"></p>
<p>EXTI框图</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151728077-865793877.png" alt="img"></p>
<h4 id="EXTI函数"><a href="#EXTI函数" class="headerlink" title="EXTI函数"></a>EXTI函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI_DeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//把EXTI的配置都清除，恢复成上电默认的状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;<span class="comment">//初始化EXTI,根据这个结构体里的参数配置EXTI外设</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;<span class="comment">//可以把参数传递的结构体变量赋一个默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;<span class="comment">//用来软件触发外部中断（参数给一个指定的中断线，就能软件触发一次这个外部中断）（如果只需要外部引脚触发中断，就不需要这个函数了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主程序里查看和清除标志位（对状态寄存器的读写）（一般的读写标志位，能不能触发中断的标志位都能读取）</span></span><br><span class="line">FlagStatus <span class="title function_">EXTI_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;<span class="comment">//可以获取指定的标志位是否被置1了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;<span class="comment">//可以对置1的标志位进行清除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断函数里查看和清除标志位（对状态寄存器的读写）（只能读写与中断有关的标志位，并且对中断是否允许做出了判断）</span></span><br><span class="line">ITStatus <span class="title function_">EXTI_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;<span class="comment">//可以获取指定的中断标志位是否被置1了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;<span class="comment">//可以对置1的中断标志位进行清除</span></span><br></pre></td></tr></table></figure>



<h3 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h3><p>AFIO主要用于引脚复用功能的选择和重定义</p>
<p>在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151749768-670230649.png" alt="img"></p>
<h3 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h3><p>用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向<br>类型：机械触点式&#x2F;霍尔传感器式&#x2F;光栅式<img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151804922-562307058.png" alt="img"></p>
<p>旋转编码器视图及框架</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151817180-1832999758.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//复位AFIO外设，清除其配置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="STM32-TIM定时器"><a href="#STM32-TIM定时器" class="headerlink" title="STM32-&gt;TIM定时器"></a>STM32-&gt;TIM定时器</h3><h4 id="定时器通道引脚"><a href="#定时器通道引脚" class="headerlink" title="定时器通道引脚"></a>定时器通道引脚</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151841380-1286538001.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>编号</strong></th>
<th><strong>总线</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>高级定时器</td>
<td>TIM1、TIM8</td>
<td>APB2</td>
<td>拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td>
</tr>
<tr>
<td>通用定时器</td>
<td>TIM2、TIM3、TIM4、TIM5</td>
<td>APB1</td>
<td>拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td>
</tr>
<tr>
<td>基本定时器</td>
<td>TIM6、TIM7</td>
<td>APB1</td>
<td>拥有定时中断、主模式触发DAC的功能</td>
</tr>
</tbody></table>
<h4 id="TIM（Timer）定时器"><a href="#TIM（Timer）定时器" class="headerlink" title="TIM（Timer）定时器"></a>TIM（Timer）定时器</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151854223-515763241.png" alt="img"></p>
<p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断<br>16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时<br>不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能<br>根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
<h4 id="定时器图示"><a href="#定时器图示" class="headerlink" title="定时器图示"></a>定时器图示</h4><p>高级定时器图示</p>
<p>(增加了重复计数寄存器，原先结构每个计数周期结束都会发生更新，这里可以实现每隔几个技术周期发生更新（相当于对输出的更新信号又做了一次分频）)</p>
<p>DTG(Dead Time Generate死区生成电路)（右边的输出引脚由一个变成了两个互补的输出，输出一对互补的PWM波（为了驱动三项无刷电机（三项无刷电机的驱动电路需要三个桥臂，每个桥臂需要两个大功率开关管控制，总共需要六个大功率开关）为了防止互补输出的PWM驱动桥臂时，在开关切换的瞬间，由于器件的不理想，造成短暂的直通现象，所以前面加上死区生成电路，在开关切换的瞬间，产生一定时长的死区，让桥臂的上下管全部关断，防止直通现象））</p>
<p>(增加了刹车输入功能（为了给电机驱动提供安全保障）如果外部引脚BKIN（break in）产生了刹车信号或者内部时钟失效产生故障，那么控制电路就会自动切断电机的输出，防止意外发生)</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151914707-1323509025.png" alt="img"></p>
<p>通用定时器图示（计数器向上计数，向下计数，中央对齐计数模式）</p>
<p>外部时钟模式2：想在ETR外部引脚提供时钟或者对ETR时钟进行计数，把定时器当作定时器用（外部时钟首选）</p>
<p>外部时钟模式1：将TRGI触发输入当作外部时钟输入（通过这一路的外部时钟有1.ETR引脚信号（这一路输入会占用触发输入的通道）2.ITR信号（这一部分时钟信号来自其他定时器）3.CH1引脚的边沿（上升沿下降沿都可）4.CH1引脚和CH2引脚）（通过外部时钟模式1的ITR，TRGO连接方式可以实现定时器的级联）</p>
<p>（外部ETR引脚和TRGI可以提供时钟）（TRGI用作触发输入，可以触发定时器的从模式））（在此处将TRGI触发输入当作外部时钟输入）（主模式的输出TRGO可以通向其他定时器的ITR引脚）（ITR0~ITR3分别来自其他四个定时器的输出，如下表TIM2的ITR0是接在TIM1的TRGO上的，TIM2的ITR1是接在TIM8的TRGO上，以此类推）</p>
<table>
<thead>
<tr>
<th>从定时器</th>
<th>ITR0 (TS &#x3D; 000)</th>
<th>ITR1 (TS &#x3D; 001)</th>
<th>ITR2 (TS &#x3D; 010)</th>
<th>ITR3 (TS &#x3D; 011)</th>
</tr>
</thead>
<tbody><tr>
<td>TIM2</td>
<td>TIM1</td>
<td>TIM8</td>
<td>TIM3</td>
<td>TIM4</td>
</tr>
<tr>
<td>TIM3</td>
<td>TIM1</td>
<td>TIM2</td>
<td>TIM5</td>
<td>TIM4</td>
</tr>
<tr>
<td>TIM4</td>
<td>TIM1</td>
<td>TIM2</td>
<td>TIM3</td>
<td>TIM8</td>
</tr>
<tr>
<td>TIM5</td>
<td>TIM2</td>
<td>TIM3</td>
<td>TIM4</td>
<td>TIM8</td>
</tr>
</tbody></table>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227151928655-2054898411.png" alt="img"></p>
<p>基本定时器图示（计数器向上计数）</p>
<p>（产生更新中断或者更新事件）（更新事件不会触发中断，但可以触发内部其他电路的工作）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152006599-1737193749.png" alt="img"></p>
<h4 id="定时器定时中断流程："><a href="#定时器定时中断流程：" class="headerlink" title="定时器定时中断流程："></a>定时器定时中断流程：</h4><p>（内部时钟）基准时钟–&gt;预分频器–&gt;计数器–&gt;计数器计数自增，同时不断与自动重装寄存器进行比较–&gt;它俩值相等时，计时时间到，产生一个更新中断或者更新事–&gt;CPU响应更新中断，完成定时中断的任务</p>
<h4 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h4><p>（STM32定时器一大特色）它能让内部的硬件在不受程序的控制下实现自动运行</p>
<p>eg:主模式触发DAC：当用DAC输出一段波形时，需要每隔一段时间来触发DAC，让它输出下一个电压点–&gt;定时器设计了一个主模式，使用这个主模式可以把这个定时器的更新事件映射到这个触发输出TRGO(Trigger Out)的位置，然后TRGO直接接到DAC的触发转换引脚上。</p>
<h4 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152019354-1404291025.png" alt="img"></p>
<p>（中断输出控制就是中断输出的允许位）</p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><h5 id="预分频器时序图"><a href="#预分频器时序图" class="headerlink" title="预分频器时序图"></a>预分频器时序图</h5><p>CK_PSC:预分频器的输入时钟</p>
<p> CNT_EN:计数器使能（高电平计数器正常运行，低电平计数器停止）</p>
<p>CK_CNT：计数器时钟（预V分频器的时钟输出，计数器的时钟输入）（看图，前半段，计数器未使能，计数器&#x2F;定时器时钟不运行，使能后，前半段，预分频器系数为1，计数器时钟等于预分频器时钟，后半段，预分频器系数为2，计数器时钟等于预分频器时钟的一半）（预分频器系数&#x3D;预分频值+1）（在计数器时钟的驱使下，计数器寄存器也跟着时钟的上升沿而不断自增）</p>
<p>计数器计数频率：CK_CNT &#x3D; CK_PSC &#x2F; (PSC + 1)</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152035785-11546224.png" alt="img"></p>
<h5 id="计数器时序图"><a href="#计数器时序图" class="headerlink" title="计数器时序图"></a>计数器时序图</h5><p>CK_INT：内部时钟72MHz</p>
<p>CNT_EN:时钟使能，高电平启动</p>
<p>CK_CNT:计数器时钟&#x2F;定时器时钟：（eg:频率为CK_CNT&#x2F;分频系数&#x3D;36MHz）</p>
<p>更新中断标志位UIF：只要置1了，就回去申请中断，中断响应后，需要<strong>手动</strong>清零</p>
<p>计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)<br>					       &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p>
<p>溢出时间&#x3D;1&#x2F;溢出频率</p>
<p><u>（ARR:自动重装载值）</u></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152114391-1064811219.png" alt="img"></p>
<h5 id="计数器无预装时序图"><a href="#计数器无预装时序图" class="headerlink" title="计数器无预装时序图"></a>计数器无预装时序图</h5><p>（无缓冲寄存器&#x2F;影子寄存器）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152134614-1909809547.png" alt="img"></p>
<h5 id="计数器有预装时序图"><a href="#计数器有预装时序图" class="headerlink" title="计数器有预装时序图"></a>计数器有预装时序图</h5><p>（有缓冲寄存器&#x2F;影子寄存器）</p>
<p>（让值的变化与更新事件同步发生，防止在运行途中更改造成错误）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152147599-1931023227.png" alt="img"></p>
<h5 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h5><p>STM32中用来产生和配置时钟，并且把配置好的时钟发送到各个外设的系统（时钟是所有外设运行的基础，是最先需要配置的东西（主函数运行前执行的SystemInit函数就是用来配置RCC时钟树的））</p>
<p>图示左侧都是时钟的产生电路，右侧都是时钟的分配电路(SYSCLK-&gt;系统时钟72MHz)(时钟产生电路：四个震荡源：内部的8MHz高速RC振荡器，外部的4-16MHz高速石英晶体振荡器—&gt;晶振（一般8MHzx），外部的32.768KHz低速晶振-&gt;给RTC提供时钟，内部40KHz低速RC振荡器-&gt;给看门狗提供时钟)（AHB,APB1,APB2的时钟来自这两个高速晶振）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152212171-2076256006.png" alt="img"></p>
<h3 id="TIM输出比较"><a href="#TIM输出比较" class="headerlink" title="TIM输出比较"></a>TIM输出比较</h3><p>输出比较：OC</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152223980-112883284.png" alt="img"></p>
<p>输出比较八种模式</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152237797-476936291.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152247652-456208791.png" alt="img"></p>
<h4 id="TIM函数"><a href="#TIM函数" class="headerlink" title="TIM函数"></a>TIM函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_DeInit</span><span class="params">(TIM_TypeDef* TIMx)</span>;<span class="comment">//恢复缺省配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时基单元</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;<span class="comment">//时基单元初始化（TIMx，结构体（包含配置时基单元的一些参数））</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseStructInit</span><span class="params">(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;<span class="comment">//可以把结构体变量赋一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;<span class="comment">//用来使能计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断输出控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;<span class="comment">//使能中断输出信号（使能外设的中断输出）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时基单元的时钟源选择部分（RCC内部时钟，ETR外部时钟，ITRx其他定时器，TIx捕获通道）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;<span class="comment">//选择内部时钟（TIMx）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;<span class="comment">//选择ITRx其他定时器时钟（TIMx,选择要接入的哪个其他定时器）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource, <span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;<span class="comment">//选择TIX捕获通道的时钟（TIMx，选择TIx具体的某个引脚，输入的极性，输入的滤波器）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;<span class="comment">//选择ETR通过外部时钟模式1输入的时钟（TIMx，外部触发预分频器，输入极性，输入滤波器）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler,<span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;<span class="comment">//选择ETR通过外部时钟模式2输入的时钟（TIMx，外部触发预分频器，输入极性，输入滤波器）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;<span class="comment">//不是用来选择时钟，而是单独用来配置ETR引脚的预分频器，极性，滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;<span class="comment">//单独写预分频值（要写入的预分频值，写入的模式（听从安排，在更新事件后生效或者在写入后手动产生一个更新事件让值立刻生效））</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;<span class="comment">//用来改变计数器的计数模式（TIMx，选择新的计数器模式）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;<span class="comment">//自动重装器预装功能配置（TIMx,使能还是失能-&gt;有预装或者无预装）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;<span class="comment">//给计数器手动写入一个值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;<span class="comment">//给自动重装器手动写入一个值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;<span class="comment">//获取当前计数器的值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;<span class="comment">//获取当前预分频器的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取标志位和清除标志位</span></span><br><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是输出比较函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;<span class="comment">//（选择定时器，结构体（输出比较的参数））</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">//（0c:输出比较）（输出比较单元有四个与之一一对应）（选择定时器，结构体（输出比较的参数））</span></span><br><span class="line"><span class="comment">//（结构体来初始化输出比较单元）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;<span class="comment">//用来给输出比较赋一个默认值的</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="comment">//配置强制输出模式（用于在运行过程中暂停输出波形并强制输出高或低电平）（等于设置100%或0%占空比效果类似，所以用的不多）（不掌握）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="comment">//配置CCR寄存器的预装功能（即影子寄存器，写入的值在更新事件后才生效）（不掌握）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="comment">//配置快速使能（不掌握）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="comment">//外部事件清除REF信号（不掌握）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="comment">//单独设置输出比较的极性（不掌握）（带个N的是高级定时器里互补通道的配置）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;</span><br><span class="line"><span class="comment">//单独修改输出使能参数的</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;</span><br><span class="line"><span class="comment">//单独更改输出比较模式的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;</span><br><span class="line"><span class="comment">//单独更改CCR寄存器值的函数（用于在运行时更改占空比）（比较重要）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//仅高级定时器使用，在使用高级定时器输出PWM时，需要调用这个函数，使能主输出，否则PWM将不能正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是输出比较函数</span></span><br></pre></td></tr></table></figure>

<h4 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152310595-1774164142.png" alt="img"></p>
<p>把模块都打通，就可以输出PWM了</p>
<p>1.RCC开启时钟，把要用的TIM外设和GPIO外设的时钟打开</p>
<p>2.配置时基单元，包括前面的时钟源选择</p>
<p>3.配置输出比较单元，包括CCR的值，输出比较模式，极性选择，输出使能等参数（在库函数里用结构体来配置）</p>
<p>4。配置GPIO，把PWM对应的GPIO口初始化为复用推挽输出</p>
<p>5。运行控制，启动计数器，输出PWM</p>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152323022-1596337104.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152344501-1945178892.png" alt="img"></p>
<h3 id="串口参数"><a href="#串口参数" class="headerlink" title="串口参数"></a>串口参数</h3><p>波特率：串口通信的速率<br>起始位：标志一个数据帧的开始，固定为低电平<br>数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行<br>校验位：用于数据验证，根据数据位计算得来<br>停止位：用于数据帧间隔，固定为高电平</p>
<h3 id="串口中断"><a href="#串口中断" class="headerlink" title="串口中断"></a>串口中断</h3><p>串口内部有两个寄存器：发送数据寄存器（TDR），发送移位寄存器</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152357292-1536704779.png" alt="img"></p>
<h2 id="STM调试"><a href="#STM调试" class="headerlink" title="STM调试"></a>STM调试</h2><p>keil 5调试</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152420039-1688714122.png" alt="img"></p>
<h2 id="RTC实现"><a href="#RTC实现" class="headerlink" title="RTC实现"></a>RTC实现</h2><h3 id="RTC代码实现所需函数"><a href="#RTC代码实现所需函数" class="headerlink" title="RTC代码实现所需函数"></a>RTC代码实现所需函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复位BKP的值为默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能外部晶振，查看时钟树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSEConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_LSE)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向指定的用户寄存器吗写入用户程序数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_WriteBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//从指定的后备寄存器读出数据</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">BKP_ReadBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在备份域控制寄存器中（RCC_BDCR）里的LSERDY指示LSE晶体震荡是否稳定</span></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC时钟源选择和时钟使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_RTCCLKSource)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待RTC的寄存器域RTC的APB时钟同步：等待RTC寄存器（RTC_CNT,RTC_ALR，RTC_PRL）于RTC的APB时钟同步</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForSynchro</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//等待RTC寄存器完成：等待最近一次对RTC的寄存器写操作完成</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForLastTask</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能RTC秒中断，产生秒中断</span></span><br><span class="line"><span class="comment">//RTC_RT值包括：RTC_IT_ON(溢出中断使能)，RTC_IT_ALR（闹钟中断使能），RTC_IT_SEC(秒中断使能)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ITConfig</span><span class="params">(<span class="type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入RTC配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EnterConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//允许配置</span></span><br><span class="line"><span class="comment">//推出配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ExitConfigMode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置RTC预分频的值：预分频配置：PRLH/PRLL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> PrescalerValue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearFlag</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;<span class="comment">//清除复位标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取RTC计数器的值</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetCounter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//设置RTC计数器的值：CNTH/CNTL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetCounter</span><span class="params">(<span class="type">uint32_t</span> CounterValue)</span>;<span class="comment">//设置RTC计数器的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置RTC闹钟的值：ALRH/ALRL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetAlarm</span><span class="params">(<span class="type">uint32_t</span> AlarmValue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查RTC的中断发生与否</span></span><br><span class="line">ITStatus <span class="title function_">RTC_GetITStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除RTC的中断待处理位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearITPendingBit</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="RTC配置流程"><a href="#RTC配置流程" class="headerlink" title="RTC配置流程"></a>RTC配置流程</h3><p>使能PWR和BKP时钟</p>
<p>使能后备寄存器访问</p>
<p>配置RTC时钟源，使能RTC时钟</p>
<p>如果使用LSE，要打开LSE</p>
<p>配置RTC预分频器系数</p>
<p>设置时间</p>
<p>开启相关中断（如果需要）</p>
<p>编写中断服务函数</p>
<p>部分操作要等待写操作和完成和同步</p>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>SCL和SDA应该外挂上拉电阻</p>
<h3 id="软件I2C"><a href="#软件I2C" class="headerlink" title="软件I2C"></a>软件I2C</h3><p>不用看I2C的库函数，只需要用GPIO的读取函数</p>
<h4 id="软件I2C初始化"><a href="#软件I2C初始化" class="headerlink" title="软件I2C初始化"></a>软件I2C初始化</h4><ul>
<li>把SCL和SDA都初始化为开漏输出模式</li>
<li>把SCL和SDA都置高电平</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SCL PB10,SDA PB11</span></span><br><span class="line"><span class="comment">//I2C初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;<span class="comment">//开漏输出  （开漏输出模式仍然可以输入，输入时，先输出1，再直接读取输入数据就行）</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOB, GPIO_Pin_10|GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用MyI2C_Init函数PB10,PB11两个端口就被初始化为开漏输出模式，然后释放总线，SCL和SDA处于高电平，此时I2C总线处于空闲状态</span></span><br></pre></td></tr></table></figure>



<p>完成I2C的六个时序基本单元</p>
<p>(所有的单元都会保证以SCL低电平结束)</p>
<h4 id="0，封装"><a href="#0，封装" class="headerlink" title="0，封装"></a>0，封装</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_10,(BitAction)BitValue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_11,(BitAction)BitValue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint8_t</span> BitValue;</span><br><span class="line">  BitValue=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11);</span><br><span class="line">    Delay_us(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> BitValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-起始条件"><a href="#1-起始条件" class="headerlink" title="1.起始条件"></a>1.起始条件</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152436710-1228942409.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先SCL和SDA都确保释放，然后先拉低SDA,再拉低SCL，就能产生起始条件了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">	 MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">     MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">     MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-终止条件"><a href="#2-终止条件" class="headerlink" title="2.终止条件"></a>2.终止条件</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152446466-1877468206.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">     MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">     MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">	 MyI2C_W_SDA(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.发送一个字节</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152457364-1970908243.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SCL低电平变换数据，高电平保持数据稳定（高位先行，先放最高位，再放次高位，等等，最后最低位，依次把一个字节的每一位放在SDA线上，每放完一位后，执行释放SCL，拉低SCL的操作）</span></span><br><span class="line"><span class="comment">//首先趁SCL低电平，先把Byte的最高位放在SDA线上（写SDA,写1还是写0取决于Byte的最高位）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MyI2C_W_SDA(Byte&amp;(<span class="number">0x80</span>&gt;&gt;i));<span class="comment">//0x80:1000 0000  ,把Byte的第i位放在SDA线上</span></span><br><span class="line">     MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//释放SCL</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">0</span>);  <span class="comment">//拉低SCL</span></span><br><span class="line">    <span class="comment">//驱动时钟走一个脉冲</span></span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.接收一个字节</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152509396-1398290698.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收一个字节时序开始时，SCL低电平，此时从机需要把数据放在SDA上，为了防止主机干扰从机写入数据，主机需要先释放SDA，释放SDA也相当于切换输入模式，在SCL低电平时，从机会把数据放到SDA，如果从机想发1，就释放SDA，如果从机想发0，就拉低SDA，然后主机释放SCL，在SCL高电平期间读取SDA,再拉低SCL，低电平期间，从机会把下一位数据放到SDA上，重复八次，主机就能读到一个字节了（SCL低电平变换数据，高电平读取数据，是一种读写分离的设计，低电平时间定义为写的时间，高电平期间定义为读的时间，如果非要在SCL高电平时变换数据，就变成了起始条件或者终止条件）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i, Byte =<span class="number">0x00</span>;</span><br><span class="line"> 	 MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>)</span><br><span class="line">    &#123;Byte |=( MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>)</span><br><span class="line">    &#123;Byte |=<span class="number">0x80</span>;&#125;&gt;&gt;i);&#125;</span><br><span class="line">        MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Byte;</span><br><span class="line"> &#125;</span><br><span class="line">         </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="5-发送应答，接收应答"><a href="#5-发送应答，接收应答" class="headerlink" title="5.发送应答，接收应答"></a>5.发送应答，接收应答</h4><p>（发送一个字节就是发8位，发送应答就是发1位）接收应答（接收一个字节就是收八位，接收应答就是收一位）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152520572-575444862.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送应答</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(AckBit);<span class="comment">//主机把AckBit放在SDA上</span></span><br><span class="line">     MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//释放SCL，SCL高电平，从机读取应答，SCL低电平，进入下一个时序单元</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">0</span>);  <span class="comment">//拉低SCL</span></span><br><span class="line">    <span class="comment">//驱动时钟走一个脉冲</span></span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收应答  读到0，代表从机给了应答，读到1，代表从机没给应答</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;<span class="comment">//函数进来时，SCL低电平，</span></span><br><span class="line">    <span class="type">uint8_t</span> AckBit;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//主机释放SDA，防止干扰从机，同时，从机把应答位放在SDA上</span></span><br><span class="line">     MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL高电平</span></span><br><span class="line">    AckBit=MyI2C_R_SDA();<span class="comment">//主机读取应答位</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">0</span>); <span class="comment">//SCL低电平，进入下一个时序单元</span></span><br><span class="line">         </span><br><span class="line"> <span class="comment">//I2C的引脚都是开漏输出+弱上拉的配置，主机输出1，并不是强制SDA为高电平，而是释放SDA</span></span><br><span class="line">    <span class="comment">//I2C是在进行通信，主机释放SDA，从机会对SDA操作，即使之前主机把SDA置1，之后再读取SDA，读到的值也可能是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="软件I2C读取MPU6050"><a href="#软件I2C读取MPU6050" class="headerlink" title="软件I2C读取MPU6050"></a>软件I2C读取MPU6050</h3><h4 id="MPU读写字节封装"><a href="#MPU读写字节封装" class="headerlink" title="MPU读写字节封装"></a>MPU读写字节封装</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS  0xD0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span><span class="comment">//实现指定地址写单个字节（多个字节用for循环）</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Start();<span class="comment">//起始时序</span></span><br><span class="line">    MyI2C_SendByte(MPU6050_ADDRESS);<span class="comment">//发送一个字节 0xD0:从机地址+读写位</span></span><br><span class="line">    MyI2C_ReceiveAck();<span class="comment">//接收应答  返回一个值：应答位</span></span><br><span class="line">    <span class="comment">//这里有应答位可以判断从机有没有接收到数据</span></span><br><span class="line">    <span class="comment">//寻址找到从机之后，就可以发送下一个字节了</span></span><br><span class="line">     MyI2C_SendByte(RegAddress);<span class="comment">//第二个字节的内容，就是指定寄存器地址，这个字节会存在MPU6050的当前地址指针里面，用于指定具体读写哪个寄存器</span></span><br><span class="line">    <span class="comment">//发送一个字节后，也得接收一下应答</span></span><br><span class="line">    MyI2C_ReceiveAck();	</span><br><span class="line">    MyI2C_SendByte(Data);<span class="comment">//第三个字节，就是我要写入指定寄存器地址下的数据了</span></span><br><span class="line">    MyI2C_ReceiveAck();	<span class="comment">//接收应答</span></span><br><span class="line">    MyI2C_Stop();<span class="comment">//终止这个时序</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span><span class="comment">//实现指定地址读单个字节，参数是指定读的地址</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_T Data;</span><br><span class="line">    MyI2C_Start();<span class="comment">//起始时序</span></span><br><span class="line">    MyI2C_SendByte(MPU6050_ADDRESS);<span class="comment">//发送一个字节 0xD0:从机地址+读写位</span></span><br><span class="line">    MyI2C_ReceiveAck();<span class="comment">//接收应答  返回一个值：应答位</span></span><br><span class="line">    <span class="comment">//这里有应答位可以判断从机有没有接收到数据</span></span><br><span class="line">    <span class="comment">//寻址找到从机之后，就可以发送下一个字节了</span></span><br><span class="line">     MyI2C_SendByte(RegAddress);<span class="comment">//第二个字节的内容，就是指定寄存器地址，这个字节会存在MPU6050的当前地址指针里面，用于指定具体读读哪个寄存器</span></span><br><span class="line">    <span class="comment">//发送一个字节后，也得接收一下应答</span></span><br><span class="line">    MyI2C_ReceiveAck();	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定地址就是设定了MPU6050的当前地址指针，设定完地址之后，我们要转入读的时序，必须重新指定读写位，必须重新起始</span></span><br><span class="line">    MyI2C_Start();<span class="comment">//起始时序</span></span><br><span class="line">    MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//指定从机地址和读写位，从机地址仍然是MPU6050的地址，但是是写地址，读写位是1</span></span><br><span class="line">    MyI2C_ReceiveAck();	<span class="comment">//接收应答</span></span><br><span class="line">    <span class="comment">//总线控制权正式交给从机</span></span><br><span class="line">    <span class="comment">//从机开始发送一个字节，主机就是调用-&gt;</span></span><br><span class="line">    Data=MyI2C_ReceiveByte()<span class="comment">//接收一个字节，这个函数的返回值就是接收到的数据</span></span><br><span class="line">     <span class="comment">//主机接收一个字节后，要给从机发送一个应答</span></span><br><span class="line">        MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//0给从机应答 1不给从机应答（不想继续读了就不给应答，主机收回总线的控制权），这里只读一个数据</span></span><br><span class="line">    MyI2C_Stop();<span class="comment">//终止时序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Data;<span class="comment">//把读到的数据返回回去，想读多个字节就用for循环（读取最后一个字节给非应答）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="MPU初始化，获取数据封装"><a href="#MPU初始化，获取数据封装" class="headerlink" title="MPU初始化，获取数据封装"></a>MPU初始化，获取数据封装</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Init();</span><br><span class="line">    MPU6050_Init();</span><br><span class="line"><span class="comment">//调用读写寄存器的地址</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//参数是要读的寄存器地址,返回值是ID号的内容</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写寄存器，首先需要解除芯片的睡眠模式，否则写入无效</span></span><br><span class="line"><span class="comment">//睡眠模式是电源管理寄存器1的这一位SLEEP,直接将这个寄存器写入0x00,这样就能解除睡眠模式了</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Init();</span><br><span class="line">    MPU6050_Init();</span><br><span class="line"><span class="comment">//调用读写寄存器的地址</span></span><br><span class="line">MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//0x6B:电源管理寄存器地址，往内写入0x00,解除睡眠模式</span></span><br><span class="line">    <span class="comment">//采样率分频寄存器，地址是0x19，值的内容是采样分频</span></span><br><span class="line">    MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//往其中写入0xAA	</span></span><br><span class="line"><span class="type">uint8_t</span> ID = MPU6050_ReadReg(<span class="number">0x19</span>);<span class="comment">//参数是要读的寄存器地址,返回值是ID号的内容</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,ID,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	MyI2C_Init(); <span class="comment">//开启I2C通信</span></span><br><span class="line">    </span><br><span class="line">    MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1</span></span><br><span class="line">    <span class="comment">//设备复位，给0-&gt;不复位   睡眠模式，给0-&gt;解除睡眠</span></span><br><span class="line">    <span class="comment">//循环模式，给0-&gt;不需要循环 无关位，给0即可</span></span><br><span class="line">    <span class="comment">//温度传感器失能，给0-&gt;不失能，最后3位选择时钟，给000-&gt;给内部时钟，给001-&gt;选x轴的陀螺仪时钟</span></span><br><span class="line">    <span class="comment">//总：0000 0001：0x01</span></span><br><span class="line">    </span><br><span class="line">     MPU6050_WriteReg(<span class="number">0x6C</span>,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2</span></span><br><span class="line">    <span class="comment">//前两位：循环模式唤醒频率，给00-&gt;不需要</span></span><br><span class="line">    <span class="comment">//后六位：每个轴的待机位，全都给0-&gt;不需要待机</span></span><br><span class="line">    <span class="comment">//总：0000 0000：0x00</span></span><br><span class="line">    </span><br><span class="line">     MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0x09</span>);<span class="comment">//配置采样率分频寄存器</span></span><br><span class="line">    <span class="comment">//这八位决定了数据输出的快慢，值越小越快</span></span><br><span class="line">    <span class="comment">//总：0x09:10分频</span></span><br><span class="line">    </span><br><span class="line">     MPU6050_WriteReg(<span class="number">0x1A</span>,<span class="number">0x06</span>);<span class="comment">//&quot;配置寄存器&quot;</span></span><br><span class="line">    <span class="comment">//外部同步，Bit5,Bit4,Bit3全部给0-&gt;不需要</span></span><br><span class="line">    <span class="comment">//数字低通滤波器 Bit2,Bit1,Bit0给个110-&gt;最平滑的滤波</span></span><br><span class="line">    <span class="comment">//总 ：0000 0110 ：0x06</span></span><br><span class="line">    </span><br><span class="line">     MPU6050_WriteReg(<span class="number">0x1B</span>,<span class="number">0x18</span>);<span class="comment">//陀螺仪配置寄存器</span></span><br><span class="line">    <span class="comment">//Bit7,Bit6,Bit5自测使能 都给0-&gt;不自测	</span></span><br><span class="line">    <span class="comment">//Bit4,Bit3满量程选择 给11-&gt;选择最大量程</span></span><br><span class="line">    <span class="comment">//Bit2,Bit1,Bit0 无关位给000</span></span><br><span class="line">    <span class="comment">//总：0001 1000：0x18</span></span><br><span class="line">    </span><br><span class="line">   MPU6050_WriteReg(<span class="number">0x1C</span>,<span class="number">0x18</span>); <span class="comment">//加速度计配置寄存器</span></span><br><span class="line">    <span class="comment">//Bit7,Bit6,Bit5自测使能 都给0-&gt;不自测</span></span><br><span class="line">    <span class="comment">//Bit4,Bit3满量程选择 给11-&gt;选择最大量程</span></span><br><span class="line">    <span class="comment">//高通滤波器 Bit2,Bit1,Bit0给个000-&gt;用不到</span></span><br><span class="line">    <span class="comment">//总：0001 1000：0x18</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总：解除睡眠，选择陀螺仪时钟，六个轴均不待机采样分频为10，滤波参数给最大陀螺仪和加速度计都选择最大量程</span></span><br><span class="line">    <span class="comment">//配置完之后，陀螺仪内部就在不断地进行数据转换了，输出的数据就存放在就存放在数据寄存器里，想获取数据的话，只需要再写一个获取数据寄存器的函数即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY，<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY，<span class="type">int16_t</span> *GyroZ)</span><span class="comment">//这个函数需要返回6个int16_t的数据，分别表示XYZ轴的加速度值和陀螺仪值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Data_H,Data_L;</span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x3B</span>);<span class="comment">//首先读取加速度寄存器X轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x3C</span>);<span class="comment">//再读取加速度寄存器的低8位</span></span><br><span class="line">    *AccX=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是加速度计X轴的16位数据</span></span><br><span class="line">    </span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x3D</span>);<span class="comment">//首先读取加速度寄存器Y轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x3E</span>);<span class="comment">//再读取加速度寄存器的低8位</span></span><br><span class="line">    *AccY=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是加速度计Y轴的16位数据</span></span><br><span class="line">    </span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x3F</span>);<span class="comment">//首先读取加速度寄存器Z轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x40</span>);<span class="comment">//再读取加速度寄存器的低8位</span></span><br><span class="line">    *AccZ=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是加速度计Z轴的16位数据</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x43</span>);<span class="comment">//首先读取陀螺仪寄存器X轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x44</span>);<span class="comment">//再读取陀螺仪寄存器的低8位</span></span><br><span class="line">    *AccX=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是陀螺仪计X轴的16位数据</span></span><br><span class="line">    </span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x45</span>);<span class="comment">//首先读取陀螺仪寄存器Y轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x46</span>);<span class="comment">//再读取陀螺仪寄存器的低8位</span></span><br><span class="line">    *AccY=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是陀螺仪Y轴的16位数据</span></span><br><span class="line">    </span><br><span class="line">    Data_H=MPU6050_ReadReg(<span class="number">0x47</span>);<span class="comment">//首先读取陀螺仪寄存器Z轴的高8位</span></span><br><span class="line">    Data_L=MPU6050_ReadReg(<span class="number">0x48</span>);<span class="comment">//再读取陀螺仪寄存器的低8位</span></span><br><span class="line">    *AccZ=(Data_H&lt;&lt;<span class="number">8</span>)|Data_L;<span class="comment">//高八位左移八位再或上低八位就是陀螺仪Z轴的16位数据    </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="I2C通信外设"><a href="#I2C通信外设" class="headerlink" title="I2C通信外设"></a>I2C通信外设</h3><p>（同步时序）（硬件I2C）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152544908-733690955.png" alt="img"></p>
<p>由硬件电路自动反转引脚电平</p>
<p>软件只需要写入控制寄存器CR（踩油门，打方向盘）,数据寄存器DR（看仪表盘），就可以实现协议了。</p>
<p>为了实时监控时序的状态，软件还得读取状态寄存器SR（观看仪表盘，了解汽车的运行状态）</p>
<p>掌握一主多从，7位地址的I2C（起始条件之后，紧跟的一个字节必须是7位地址+读写位）</p>
<p>主机：拥有主动控制总线的权利。从机：只能在主机允许的情况下，才能控制总线</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152555993-136125364.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152605263-220342738.png" alt="img"></p>
<p>I2C是高位先行，在发送的时候，最高位先移出去	，然后是次高位</p>
<p>移位8次，就能发送一个字节</p>
<p>在接收的时候，数据通过GPIO口从右边依次移进来，移8次，一个字节就接收完成了</p>
<p>配置硬件I2C时，两个GPIO口都要配置成复用开漏输出的模式（复用：GPIO口的状态是交由片上外设来控制的。开漏输出：是I2C协议要求的端口配置（即使是开漏输出模式，GPIO口也是可以进行输入的））</p>
<p>主机发送</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152620162-1746006097.png" alt="img"></p>
<p>主机接收</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152631192-1845598711.png" alt="img"></p>
<p>起始，从机地址+读，接收应答      接收数据，发送应答    接收数据，发送应答 ，最后一个数据给非应答，之后终止（这个时序是当前地址读的时序，指定地址读的复合格式这里没有给，需要我们自己组合一下）</p>
<h4 id="硬件I2C读取MPU6050"><a href="#硬件I2C读取MPU6050" class="headerlink" title="硬件I2C读取MPU6050"></a>硬件I2C读取MPU6050</h4><ol>
<li><p>开启I2C外设和对应GPIO口的时钟</p>
</li>
<li><p>把I2C外设对应的GPIO口初始化为复用开漏模式</p>
</li>
<li><p>使用结构体，对整个I2C进行配置</p>
</li>
<li><p>I2C_Cmd 使能I2C </p>
<h5 id="硬件I2C函数"><a href="#硬件I2C函数" class="headerlink" title="硬件I2C函数"></a>硬件I2C函数</h5></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTART</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//生成起始条件，调用下这个函数，就可以生辰起始条件了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTOP</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用一下，生成终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_AcknowledgeConfig</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//配置CR1的Ack这一位，这里Ack就是应答使能（STM32作为主机，在接收一个字节后，是给从机应答，还是非应答，取决于此，Ack是1，就是给从机应答，0就是给从机非应答）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendData</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//发送数据，就是把Data这个数据直接写入到DR寄存器（数据寄存器，用于存放接收到的数据或放置用于发送到总线的数据）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveData</span><span class="params">(I2C_TypeDef* I2Cx)</span>;<span class="comment">//读取DR的数据作为返回值(在接收器模式下，接收到的字节被拷贝到DR寄存器)（读取DR，接收数据）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Send7bitAddress</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> I2C_Direction)</span>;<span class="comment">//发送七位地址的专用函数 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="硬件I2C初始化"><a href="#硬件I2C初始化" class="headerlink" title="硬件I2C初始化"></a>硬件I2C初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1开启I2C外设和对应GPIO口的时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE);    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;<span class="comment">//定义GPIO_InitStruct结构体</span></span><br><span class="line">	GPIO_InitStruct.GPIO_Mode= GPIO_Mode_AF_OD;<span class="comment">//结构体初始化—&gt;复用开漏输出</span></span><br><span class="line">	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_10|GPIO_Pin_11;<span class="comment">//结构体初始化—&gt;</span></span><br><span class="line">	GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//结构体初始化-&gt;速度</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStruct);<span class="comment">//GPIOA初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3初始化I2C外设</span></span><br><span class="line">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">	I2C_InitStructure.I2C_Ack=I2C_Ack_Enable;<span class="comment">//应答位配置，配置Ack位，用于确定在接收一个字节后是否给从机应答,之后要更改再用单独的函数更改 </span></span><br><span class="line">	I2C_InitStructure.I2C_AcknowledgedAddress=I2C_AcknowledgedAddress_7bit;<span class="comment">//指定STM32作为从机,可以响应几位的地址(可以响应10位或者7位的地址)</span></span><br><span class="line">	I2C_InitStructure.I2C_ClockSpeed=<span class="number">50000</span>;<span class="comment">//50KHz时钟速度，配置SCL的时钟频率,数值越大，SCL频率越高，数据传输就越快。0~100KHz标准速度，100KHz~400KHz：快速状态</span></span><br><span class="line">	I2C_InitStructure.I2C_DutyCycle=I2C_DutyCycle_2;<span class="comment">//时钟占空比，只用在时钟频率大于100KHz，也就是进入到快速状态时才有用,在0~100KHz的标准速度下，占空比是固定的1:1(低电平时间:高电平时间=1:1)</span></span><br><span class="line">	<span class="comment">//时钟占空比是低:高，是为了快速模式而设定的（读取速度大于写入速度）（所以给低电平的写入时间多分配点资源）</span></span><br><span class="line">	I2C_InitStructure.I2C_Mode=I2C_Mode_I2C;<span class="comment">//模式</span></span><br><span class="line">	I2C_InitStructure.I2C_OwnAddress1=<span class="number">0x00</span>;<span class="comment">//自身地址1，STM32作为从机使用，用于指定STM32的自身地址，方便别的主机呼叫它（如果上面的参数选择了响应7位地址，这里就得给STM32指定一个自身的7位地址）</span></span><br><span class="line">    I2C_Init(I2C2,&amp;I2C_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4:I2C2使能</span></span><br><span class="line">    I2C_Cmd(I2C2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="硬件I2C封装函数"><a href="#硬件I2C封装函数" class="headerlink" title="硬件I2C封装函数"></a>硬件I2C封装函数</h5><p>写寄存器，指定地址写一个字节的时序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.生成起始条件</span></span><br><span class="line">    I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">    <span class="comment">//硬件I2C是非阻塞式的程序，在函数结束之后，都要等待相应的标志位，来确保这个函数的操作执行到位了</span></span><br><span class="line">    <span class="comment">//此时要等待EV5事件的到来，检查EV5事件</span></span><br><span class="line">    <span class="comment">//用到状态监控函数</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT)!=SUCESS);<span class="comment">//监测EV5事件是否发生：主机模式选择(因为STM32默认位主机，发送起始条件之后变为主机)，EV5事件也可以叫做主机模式已选择事件，，，返回值：SUCCESS表示最后一次事件等于我们指定的事件   ERROR表示指定事件未发生</span></span><br><span class="line">    <span class="comment">//为了等待EV5事件发生，所以套while循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.发送从机地址，接收应答</span></span><br><span class="line">    <span class="comment">//发送从机地址，就是发送一个字节，直接向DR寄存器写入一个字节就行</span></span><br><span class="line">  I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//第二个参数是从机地址,采用宏定义地址，第三个参数是方向，也就是从机地址的最低为-&gt;读写位。第三个参数：Transmitter,发送，给地址的最低位清0，Receiver,接收，它就给你的地址最低位置1</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCESS);<span class="comment">//“接收模式已选择”等待EV6事件发生 </span></span><br><span class="line">    I2C_SendData(I2C2,RegAddress);<span class="comment">//第二个参数是一个字节的数据,宏定义</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCESS);<span class="comment">//等待EV8事件&quot;字节正在发送&quot;</span></span><br><span class="line">     I2C_SendData(I2C2,Data);</span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCESS);<span class="comment">//等待EV8_2事件&quot;事件已经发送完毕&quot;，移位完成了并且没有新的数据可以发的时候置BTF </span></span><br><span class="line">   I2C_GenerateSTOP(I2C2,ENABLE);<span class="comment">//生成终止条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读寄存器的函数，指定地址读寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Data;</span><br><span class="line">     <span class="comment">//1.生成起始条件</span></span><br><span class="line">    I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">    <span class="comment">//硬件I2C是非阻塞式的程序，在函数结束之后，都要等待相应的标志位，来确保这个函数的操作执行到位了</span></span><br><span class="line">    <span class="comment">//此时要等待EV5事件的到来，检查EV5事件</span></span><br><span class="line">    <span class="comment">//用到状态监控函数</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT)!=SUCESS);<span class="comment">//监测EV5事件是否发生：主机模式选择(因为STM32默认位主机，发送起始条件之后变为主机)，EV5事件也可以叫做主机模式已选择事件，，，返回值：SUCCESS表示最后一次事件等于我们指定的事件   ERROR表示指定事件未发生</span></span><br><span class="line">    <span class="comment">//为了等待EV5事件发生，所以套while循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.发送从机地址，接收应答</span></span><br><span class="line">    <span class="comment">//发送从机地址，就是发送一个字节，直接向DR寄存器写入一个字节就行</span></span><br><span class="line">  I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//第二个参数是从机地址,采用宏定义地址，第三个参数是方向，也就是从机地址的最低为-&gt;读写位。第三个参数：Transmitter,发送，给地址的最低位清0，Receiver,接收，它就给你的地址最低位置1</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCESS);<span class="comment">//“接收模式已选择”等待EV6事件发生 </span></span><br><span class="line">    I2C_SendData(I2C2,RegAddress);<span class="comment">//第二个参数是一个字节的数据,宏定义</span></span><br><span class="line">  <span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCESS);<span class="comment">//等待EV8事件&quot;字节正在发送&quot;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152650767-56308995.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152705281-527784735.png" alt="img"><br>举例：</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152751095-1984011113.png" alt="img"></p>
<h1 id="freertos"><a href="#freertos" class="headerlink" title="freertos"></a>freertos</h1><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152808687-1443820486.png" alt="img"></p>
<p>实时操作系统(允许多任务同时运行)：freertos,ucos,rt-thread</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152821392-350369421.png" alt="img"></p>
<h2 id="Freerots编程风格"><a href="#Freerots编程风格" class="headerlink" title="Freerots编程风格"></a>Freerots编程风格</h2><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152834957-1243177261.png" alt="img"></p>
<p>（int从不使用）（short是16位，long是32位）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152851807-771942128.png" alt="img"></p>
<h2 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h2><p>独立的无法返回的函数是函数</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152903237-481632599.png" alt="img"></p>
<p>任务栈</p>
<p>栈是单片机在ram中一段连续的空间</p>
<p>为每个任务分独立的栈的内存空间</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152914129-214173516.png" alt="img"></p>
<p>任务函数</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152924738-44723044.png" alt="img"></p>
<p>任务控制块</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152935506-1428393607.png" alt="img"><br>列表和列表项（C语言当中的链表）：用于跟踪任务</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152944661-1685694101.png" alt="img"></p>
<p>1和5用于检查完整性</p>
<p>2用于记录列表项数量</p>
<p>3用于记录列表当前索引项</p>
<p>4记录最后一个列表项</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227152956089-1849137041.png" alt="img"><br>3-&gt;下一个成员</p>
<p>4-&gt;前一个成员</p>
<p>6-&gt;指向就绪列表</p>
<p>迷你列表项（有些情况不需要列表项这么全的功能）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153008878-656879406.png" alt="img"></p>
<p>1.值</p>
<p>2.指向下一个</p>
<p>3.指向上一个</p>
<p>列表初始化</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153018864-694605011.png" alt="img"></p>
<p>列表项初始化</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153028273-233877776.png" alt="img"><br>列表项插入函数<br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153042426-1771192404.png" alt="img"></p>
<p>函数的具体实现过程<br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153107673-1054938073.png" alt="img"></p>
<p>任务创建函数</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153117105-709086754.png" alt="img"></p>
<p>任务就绪列表</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153136737-1361256815.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153147032-1300066630.png" alt="img"></p>
<p>调度器：实现任务切换</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153200836-1069005820.png" alt="img"></p>
<p>任务切换</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153211966-1388821852.png" alt="img"></p>
<p>总：任务创建-&gt;启动-&gt;就绪列表-&gt;任务调度-&gt;任务切换-&gt;</p>
<h2 id="任务创建实践过程"><a href="#任务创建实践过程" class="headerlink" title="任务创建实践过程"></a>任务创建实践过程</h2><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241227153221419-236176009.png" alt="img"></p>
<p>1.初始化硬件</p>
<p>2.创建开始任务（创建任务所需堆栈大小，任务控制块，任务函数）</p>
<p>3.启动任务调度器</p>
<p>main此时就完成了（函数要继续执行下去就从开始任务（开始任务有指定的任务函数）（在开始任务函数这里创建其他的任务子函数）这里）(创建完之后再删除开始任务)</p>
<h1 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h1><p>上位机：<br>上位机指可以直接发送操作指令的计算机或单片机，一般提供用户操作交互界面并向用户展示反馈数据。<br>典型设备类型：电脑，手机，平板，面板，触摸屏</p>
<p>下位机：<br>下位机指直接与机器相连接的计算机或单片机，一般用于接收和反馈上位机的指令，并且根据指令控制机器执行动作以及从机器传感器读取数据。<br>典型设备类型：PLC，STM32，51，FPGA，ARM等各类可编程芯片</p>
<p>上位机软件：<br>用于完成上位机操作交互的软件被定义为“上位机软件”；</p>
<ul>
<li>上位机给下位机发送控制命令，下位机收到此命令并执行相应的动作。</li>
<li>上位机给下位机发送状态获取命令，下位机收到此命令后调用传感器测量，然后转化为数字信息反馈给上位机。</li>
<li>下位机主动发送状态信息或报警信息给上位机。</li>
</ul>
<p>为了实现以上过程，上位机和下位机都需要单独编程，都需要专门的开发人员在各自两个平台编写代码。</p>
<p>上位机与下位机关系示意图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3cd27f205f9c07fde754986ac78ec643_720w.webp" alt="img"></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/01/03/51study.18632530/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          51study
        
      </div>
    </a>
  
  
    <a href="/2025/01/03/%E7%AF%AE%E7%90%83%E8%A7%84%E5%88%99.18632668/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">篮球规则</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 shenle
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>