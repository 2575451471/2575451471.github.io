<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>TM4C123G_study | Shenle</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="article">
<meta property="og:title" content="TM4C123G_study">
<meta property="og:url" content="https://github.com/2575451471/2575451471.github.io/2025/01/05/TM4C123G_study.18632659/index.html">
<meta property="og:site_name" content="Shenle">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190708100616504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190708100659281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190709124218959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190709125622852.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712154843399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712155058934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712155235173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712164442900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712163004163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190710181953400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190710182204486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190710182233264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190710182803366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190708100659281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712185612222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712185639520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712192258596.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190712193416887.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019063015483772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI3Njc4,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2025-01-04T17:27:00.000Z">
<meta property="article:modified_time" content="2025-02-14T20:26:54.362Z">
<meta property="article:author" content="shenle">
<meta property="article:tag" content="嵌入式ti">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190708100616504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70">
  
    <link rel="alternative" href="/atom.xml" title="Shenle" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>

<script src="/js/Counter.js"></script>

  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/header.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">shenle</a></h1>
		</hgroup>

		
			<p class="header-subtitle"></p>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
					        
								<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
					        
								<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=1941325363&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">上课笔记</a> <a href="/tags/%E5%B0%8F%E8%AE%B0/" style="font-size: 15px;">小记</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F32/" style="font-size: 15px;">嵌入式32</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F51/" style="font-size: 10px;">嵌入式51</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8Fti/" style="font-size: 10px;">嵌入式ti</a> <a href="/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B/" style="font-size: 10px;">智能车竞赛</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 20px;">编程语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">噜啦啦!</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/header.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
			        
						<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
			        
						<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-TM4C123G_study.18632659" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/05/TM4C123G_study.18632659/" class="article-date">
  	<time datetime="2025-01-04T17:27:00.000Z" itemprop="datePublished">2025-01-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TM4C123G_study
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8Fti/" rel="tag">嵌入式ti</a></li></ul>
	</div>

        

        
          
<div class="counter-tag counter">
    <span id="/2025/01/05/TM4C123G_study.18632659/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="TM4C123G_study">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <meta name="referrer" content="no-referrer"/>
<span id="more"></span>



<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><h2 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h2><p>TM4C123内部共有4个时钟源，见下表</p>
<table>
<thead>
<tr>
<th>时钟</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>内部高精度振荡器(PIOSC)</td>
<td>内部振荡器，其频率为16MHz，精度为1%，可以用来驱动PLL</td>
</tr>
<tr>
<td>主振荡器 (MOSC)</td>
<td>外部高速振荡器，频率可在4-25M间选择，可以驱动PLL（此时频率在5-25M）</td>
</tr>
<tr>
<td>低频内部振荡器 (LFIOSC)</td>
<td>适用于深度睡眠省电模式，它的频率是会改变的，范围在10KHz-90KHz之间，标准值30KHz</td>
</tr>
<tr>
<td>休眠模块时钟源</td>
<td>32.768KHz晶振，用于实时时钟源或睡眠时钟</td>
</tr>
</tbody></table>
<p> <img src="https://img-blog.csdnimg.cn/20190708100616504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p>时钟树</p>
<p> <img src="https://img-blog.csdnimg.cn/20190708100659281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="img"> </p>
<ol>
<li>MOSC和PIOSC可以用来驱动PLL</li>
<li>PLL输出锁定在400MHz，它可以在经过二分频和SYSDIV分频（这个可以程序配置）后提供系统时钟。注意TM4C123G的<strong>最大主频为80MHz</strong>，因此配置时钟的时候，<strong>若使用的PLL，最小分频数只能是2.5分频</strong>。</li>
</ol>
<h2 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h2><p> 使用函数 <code>void SysCtlClockSet(uint32_t ui32Config);</code> 进行系统时钟设置<br>这个函数参数是<strong>4个部分做按位与</strong>，包括 时钟分频SYSDIV设置，系统时钟来源（直接用振荡器，还是用PLL倍频过的），时钟源选择（对应上面表2.4），外接晶体频率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 时钟分频SYSDIV设置</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_1         0x07800000  <span class="comment">// Processor clock is osc/pll /1</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_2         0x00C00000  <span class="comment">// Processor clock is osc/pll /2</span></span></span><br><span class="line">		...</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_62        0x9EC00000  <span class="comment">// Processor clock is osc/pll /62</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_63        0x9F400000  <span class="comment">// Processor clock is osc/pll /63</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_64        0x9FC00000  <span class="comment">// Processor clock is osc/pll /64</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_2_5       0xC1000000  <span class="comment">// Processor clock is pll / 2.5</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_3_5       0xC1800000  <span class="comment">// Processor clock is pll / 3.5</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_4_5       0xC2000000  <span class="comment">// Processor clock is pll / 4.5</span></span></span><br><span class="line">		...</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_61_5      0xDE800000  <span class="comment">// Processor clock is pll / 61.5</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_62_5      0xDF000000  <span class="comment">// Processor clock is pll / 62.5</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_SYSDIV_63_5      0xDF800000  <span class="comment">// Processor clock is pll / 63.</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>系统时钟来源（直接用振荡器，还是用PLL倍频过的）</span><br><span class="line">	    <span class="meta">#<span class="keyword">define</span> SYSCTL_USE_PLL          0x00000000  <span class="comment">// System clock is the PLL clock</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_USE_OSC          0x00003800  <span class="comment">// System clock is the osc clock</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>时钟源选择（对应上面表<span class="number">2.4</span>）</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_OSC_MAIN         0x00000000  <span class="comment">// Osc source is main osc</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_OSC_INT          0x00000010  <span class="comment">// Osc source is int. osc</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_OSC_INT4         0x00000020  <span class="comment">// Osc source is int. osc /4</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_OSC_INT30        0x00000030  <span class="comment">// Osc source is int. 30 KHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_OSC_EXT32        0x80000038  <span class="comment">// Osc source is ext. 32 KHz</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span>外接晶体频率</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_1MHZ        0x00000000  <span class="comment">// External crystal is 1MHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_1_84MHZ     0x00000040  <span class="comment">// External crystal is 1.8432MHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_2MHZ        0x00000080  <span class="comment">// External crystal is 2MHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_2_45MHZ     0x000000C0  <span class="comment">// External crystal is 2.4576MHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_3_57MHZ     0x00000100  <span class="comment">// External crystal is 3.579545MHz</span></span></span><br><span class="line">		...</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_24MHZ       0x00000640  <span class="comment">// External crystal is 24.0 MHz</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> SYSCTL_XTAL_25MHZ       0x00000680  <span class="comment">// External crystal is 25.0 MHz</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MOSC频率16M，SYSDIV5分频，系统时钟源自PLL锁相环倍频，时钟源使用MOSC */</span></span><br><span class="line"><span class="comment">/* 系统时钟频率400M/2/5=40M */</span></span><br><span class="line">SysCtlClockSet(SYSCTL_SYSDIV_5|SYSCTL_XTAL_16MHZ|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN);	</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MOSC频率16M，SYSDIV2.5分频，系统时钟源自PLL锁相环倍频，时钟源使用MOSC */</span></span><br><span class="line"><span class="comment">/* 系统时钟频率400M/2/2.5=80M , 注意这是上限了*/</span></span><br><span class="line">SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MOSC频率16M，SYSDIV不分频，系统时钟来自时钟源，时钟源使用MOSC */</span></span><br><span class="line"><span class="comment">/* 系统时钟频率16M/1=16M */</span></span><br><span class="line">SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br></pre></td></tr></table></figure>

<h2 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h2><p> TM4C库提供了一个延时函数，它利用汇编，提供了跨越工具链时恒定的延迟。延时3*ui32Count个时钟周期 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">SysCtlDelay</span><span class="params">(<span class="type">uint32_t</span> ui32Count)</span>;</span><br></pre></td></tr></table></figure>

<p> 但若系统时钟频率不同，一个时钟周期的长度也不同，一旦改了系统时钟频率，延时就会变化，需要改进</p>
<p>  利用以下函数获取系统时钟频率（单位Hz） </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">SysCtlClockGet</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>假设系统时钟频率为nHz，即(n&#x2F;1000)KHz，设cnt&#x3D;(n&#x2F;1000)，每秒有1000<em>cnt个周期，每个cnt长1ms。<br>SysCtlDelay(Count)可以延时3</em>Count个周期，令Count&#x3D;cnt&#x2F;3，即可延时1个cnt长（即1ms）</p>
<ul>
<li><pre><code class="language-c">//延时n毫秒，不用考虑时钟频率
        #define delay_ms(n); SysCtlDelay(n*(SysCtlClockGet()/3000));

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不管用哪个时钟源，只要工作频率高于40MHz，就会导致实际延时时间大于设置值。原因好像是芯片内部Flash的读取频率最大只能达到40M，</span><br><span class="line">当工作频率大于40MHz时，通过预取两个字的指令来达到80M的运行主频。但是，当遇到SysCtlDelay函数这种短跳转时这个特性并不能很好的工作，每次都需要读取指令，所以时间就延长了</span><br><span class="line">也就是说如果主频大于40M，SysCtlDelay(n*(SysCtlClockGet()/3000))这个方法也不是很准，可以考虑用ROM_SysCtlDelasy()</span><br><span class="line"></span><br><span class="line"># GPIO</span><br><span class="line"></span><br><span class="line">## RGB_LED</span><br><span class="line"></span><br><span class="line"> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190708114310667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70) </span><br><span class="line"></span><br><span class="line"> ![在这里插入图片描述](https://img-blog.csdnimg.cn/201907081143272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70) </span><br><span class="line"></span><br><span class="line"> 控制LED是一个三极管开关电路，单片机PF1/PF2/PF3连接到LED_R/LED_B/LED_G，GPIO输出高电平即可点亮二极管 </span><br><span class="line"></span><br><span class="line">## 相关库函数</span><br><span class="line"></span><br><span class="line">### 1.使能外设时钟</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">（1）void SysCtlPeripheralEnable(uint32_t ui32Peripheral)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>功能：使能外设时钟<br>参数：uint32_t ui32Peripheral 要使能的外设<br>说明：从写外设使能操作完成到实际上的外设使能间有5个时钟周期的延迟，这期间内访问外设将导致一个总线错误。应注 意确保在这段时间内不访问该外设。</p>
<h3 id="2-引脚配置为输出模式"><a href="#2-引脚配置为输出模式" class="headerlink" title="2.引脚配置为输出模式"></a>2.引脚配置为输出模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）<span class="type">void</span> <span class="title function_">GPIOPinTypeGPIOOutput</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">uint8_t</span> ui8Pins)</span></span><br></pre></td></tr></table></figure>

<p>功能：引脚配置为输出模式<br>参数：<br>ui32Port GPIO口的基地址<br>ui8Pins bit-packed格式表示的引脚<br>说明：要使GPIO引脚做为GPIO输出，必须正确地配置引脚。本函数提供这些引脚的典型配置。引脚使用bit-packed 字节格式表示，每一位表示一个要访问的引脚，位0表示引脚0，位1表示引脚1，以此类推。<br>底层：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOPadConfigSet</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">uint8_t</span> ui8Pins,<span class="type">uint32_t</span> ui32Strength, <span class="type">uint32_t</span> ui32PinType)</span>;<span class="comment">//设置输出类型和强度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIODirModeSet</span><span class="params">(ui32Port, ui8Pins, GPIO_DIR_MODE_OUT)</span>;<span class="comment">//设置方向（输入or输出）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-写值到指定引脚"><a href="#3-写值到指定引脚" class="headerlink" title="3.写值到指定引脚"></a>3.写值到指定引脚</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOPinWrite</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">uint8_t</span> ui8Pins, <span class="type">uint8_t</span> ui8Val)</span>;</span><br></pre></td></tr></table></figure>

<p>功能：写值到指定引脚.<br>参数：<br>ui32Port GPIO口的基地制作.<br>ui8Pins bit-packed 格式表示的引脚<br>ui8Val 将要写入引脚的值.<br>说明：写相应位的数值到ui8Pins参数指定的引脚，写数值时不影响配置为输入的引脚状态。引脚用 bit-packed 字节格式表示, 每一个位代表一个引脚，位0表示GPIO口的引脚0，位1表示GPIO口的引脚1，以此类推。</p>
<h3 id="4-不受频率影响的延时函数"><a href="#4-不受频率影响的延时函数" class="headerlink" title="4.不受频率影响的延时函数"></a>4.不受频率影响的延时函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SysCtlDelay(<span class="number">100</span>*(SysCtlClockGet()/<span class="number">3000</span>));</span><br></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span>					<span class="comment">//通用类型和宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span>					<span class="comment">//外设和存储器的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span>				<span class="comment">//API函数中外设、状态等的标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ui8LED = <span class="number">2</span>;	<span class="comment">//2 = 0010</span></span><br><span class="line">                        <span class="comment">//1 = 0001</span></span><br><span class="line">                        <span class="comment">//8 = 0100</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//系统时钟分频器系数|选择外部晶振频率|使用PLL锁相环作为系统时钟源</span></span><br><span class="line">SysCtlClockSet(SYSCTL_SYSDIV_6|SYSCTL_XTAL_16MHZ|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN); </span><br><span class="line">	<span class="comment">//使能PF时钟</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);	</span><br><span class="line">   <span class="comment">//配置引脚为GPIO输出，底层是GPIOPadConfigSet和GPIODirModeSet	</span></span><br><span class="line">	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);						</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Turn on the LED ：PF1(R),PF2(B),PF3(G)</span></span><br><span class="line">		GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, ui8LED);	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Delay for a bit		</span></span><br><span class="line">		SysCtlDelay(<span class="number">100</span>*(SysCtlClockGet()/<span class="number">3000</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Cycle through Red, Green and Blue LEDs</span></span><br><span class="line">		<span class="comment">//写入2-&gt;4-&gt;8(0010-&gt;0100-&gt;1000)（R-&gt;B-&gt;G）</span></span><br><span class="line">		<span class="keyword">if</span> (ui8LED == <span class="number">8</span>) </span><br><span class="line">			ui8LED = <span class="number">2</span>; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			ui8LED = ui8LED*<span class="number">2</span>;								</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h1><h2 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h2><h3 id="1-设置指定引脚的中断触发类型"><a href="#1-设置指定引脚的中断触发类型" class="headerlink" title="1.设置指定引脚的中断触发类型."></a>1.设置指定引脚的中断触发类型.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOIntTypeSet</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">uint8_t</span> ui8Pins,<span class="type">uint32_t</span> ui32IntType)</span></span><br></pre></td></tr></table></figure>

<p>功能：设置指定引脚的中断触发类型.<br>参数:<br>（1）ui32Port： GPIO口的基地址<br>（2）ui8Pins： 多个bit-packed格式表示的引脚<br>（3）ui32IntType： 中断触发类型(有以下类型)
		</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_FALLING_EDGE       0x00000000  <span class="comment">// Interrupt on falling edge</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> GPIO_RISING_EDGE        0x00000004  <span class="comment">// Interrupt on rising edge</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> GPIO_BOTH_EDGES         0x00000001  <span class="comment">// Interrupt on both edges</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> GPIO_LOW_LEVEL          0x00000002  <span class="comment">// Interrupt on low level</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> GPIO_HIGH_LEVEL         0x00000006  <span class="comment">// Interrupt on high level</span></span></span><br><span class="line">		<span class="comment">//前5个都可和下面这个或运算一起作为ui32IntType参数，但不是所有引脚都支持离散中断，需要查手册</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> GPIO_DISCRETE_INT       0x00010000  <span class="comment">// Interrupt for individual pins</span></span></span><br></pre></td></tr></table></figure>

<p>说明： 为了避免毛刺引发的中断，用户必须确保GPIO口处于稳定状态时执行本函数</p>
<h3 id="2-注册GPIO中断的中断处理程序"><a href="#2-注册GPIO中断的中断处理程序" class="headerlink" title="2.注册GPIO中断的中断处理程序"></a>2.注册GPIO中断的中断处理程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOIntRegister</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">void</span> (*pfnIntHandler)(<span class="type">void</span>))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>功能：注册GPIO中断的中断处理程序<br>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）pfnIntHandler： 是GPIO中断服务程序入口地址指针。<br>说明：<br>（1）不管是什么外设触发的中断，都要先注册中断服务函数，告诉程序中断发生时去哪里，类似的函数有SysCtlIntRegister、ADCIntRegister等<br>（2）如果不利用这些中断注册函数，也可以在启动文件中修改中断向量表进行手动注册<br>（3）GPIOIntRegister只能以GPIO组为单位注册，不能精确到判断哪个引脚发生中断，因此要在中断服务函数中判断触发中断的引脚，以下为一个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIOF中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">io_interrupt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//获取中断状态</span></span><br><span class="line">	<span class="type">uint32_t</span> s = GPIOIntStatus(GPIO_PORTF_BASE, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//如果PF4触发中断</span></span><br><span class="line">			<span class="keyword">if</span>((s&amp;GPIO_PIN_4) == GPIO_PIN_4)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使能指定引脚的中断"><a href="#3-使能指定引脚的中断" class="headerlink" title="3.使能指定引脚的中断."></a>3.使能指定引脚的中断.</h3><p>void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)<br>功能：使能指定引脚的中断.<br>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags： 被禁止的中断源中断屏蔽位(指示哪些引脚中断被开启，是以下参数的逻辑或)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_0          0x00000001</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_1          0x00000002</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_2          0x00000004</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_3          0x00000008</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_4          0x00000010</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_5          0x00000020</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_6          0x00000040</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> GPIO_INT_PIN_7          0x00000080</span></span><br></pre></td></tr></table></figure>

<p>说明：这个函数是中断源级的中断使能控制</p>
<h3 id="4-使能一个中断"><a href="#4-使能一个中断" class="headerlink" title="4.使能一个中断"></a>4.使能一个中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IntEnable</span><span class="params">(<span class="type">uint32_t</span> ui32Interrupt)</span></span><br></pre></td></tr></table></figure>

<p>功能：使能一个中断<br>参数:<br>（1）ui32Interrupt 指定的被允许的中断.<br>说明：这个函数是中断控制器级的中断使能控制</p>
<h3 id="5-使能处理器中断"><a href="#5-使能处理器中断" class="headerlink" title="5.使能处理器中断"></a>5.使能处理器中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IntMasterEnable</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>功能：使能处理器中断.<br>参数：无<br>说明：<br>（1）这是处理器级的中断使能控制，它决定处理器要不要处理中断控制器的请求<br>（2）以上三个函数，从低级到高级对应了中断处理通路的三道“开关”，如下图所示</p>
<p> <img src="https://img-blog.csdnimg.cn/20190709124218959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="6-读取指定GPIO口的中断状态"><a href="#6-读取指定GPIO口的中断状态" class="headerlink" title="6.读取指定GPIO口的中断状态"></a>6.读取指定GPIO口的中断状态</h3><p>说明：这个函数是中断源级的中断使能控制<br>（4）void IntEnable(uint32_t ui32Interrupt)<br>功能：使能一个中断<br>参数:<br>（1）ui32Interrupt 指定的被允许的中断.<br>说明：这个函数是中断控制器级的中断使能控制<br>（5）bool IntMasterEnable(void)<br>功能：使能处理器中断.<br>参数：无<br>说明：<br>（1）这是处理器级的中断使能控制，它决定处理器要不要处理中断控制器的请求<br>（2）以上三个函数，从低级到高级对应了中断处理通路的三道“开关”，如下图所示</p>
<p>（3）void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)<br>功能：使能指定引脚的中断.<br>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags： 被禁止的中断源中断屏蔽位(指示哪些引脚中断被开启，是以下参数的逻辑或)<br>		#define GPIO_INT_PIN_0          0x00000001<br>		#define GPIO_INT_PIN_1          0x00000002<br>		#define GPIO_INT_PIN_2          0x00000004<br>		#define GPIO_INT_PIN_3          0x00000008<br>		#define GPIO_INT_PIN_4          0x00000010<br>		#define GPIO_INT_PIN_5          0x00000020<br>		#define GPIO_INT_PIN_6          0x00000040<br>		#define GPIO_INT_PIN_7          0x00000080<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>说明：这个函数是中断源级的中断使能控制<br>（4）void IntEnable(uint32_t ui32Interrupt)<br>功能：使能一个中断<br>参数:<br>（1）ui32Interrupt 指定的被允许的中断.<br>说明：这个函数是中断控制器级的中断使能控制<br>（5）bool IntMasterEnable(void)<br>功能：使能处理器中断.<br>参数：无<br>说明：<br>（1）这是处理器级的中断使能控制，它决定处理器要不要处理中断控制器的请求<br>（2）以上三个函数，从低级到高级对应了中断处理通路的三道“开关”，如下图所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">GPIOIntStatus</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">bool</span> bMasked)</span></span><br></pre></td></tr></table></figure>

<p>功能：读取指定GPIO口的中断状态<br>参数：<br>（1）ui32Port： GPIO口的基地址.<br>（2）bMasked： 指定返回屏蔽的中断状态还是原始的中断状态<br>说明： 如果bMasked被设置为真，则函数返回被屏蔽的中断状态，否则返回原始的中断状态。解释一下所谓“被屏蔽的中断状态”。在GPIOIntEnable这个函数中，没有写在第二个参数ui32IntFlags中的引脚是被屏蔽的（即不处理它们的中断事件）。当bMasked为真时，返回GPIOMIS寄存器值，所有被屏蔽的位都是0，否则返回GPIORIS寄存器值，被屏蔽的位也可能是1（因为虽然不处理这些引脚的中断事件，但它们的输入也可能符合中断特征）</p>
<p>返回值：返回指定GPIO口当前的中断状态，返回值是当前有效的GPIO_INT_∗values的逻辑或. <img src="https://img-blog.csdnimg.cn/20190709125622852.png" alt="在这里插入图片描述"> </p>
<h3 id="7-清除指定中断源标志"><a href="#7-清除指定中断源标志" class="headerlink" title="7.清除指定中断源标志"></a>7.清除指定中断源标志</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOIntClear</span><span class="params">(<span class="type">uint32_t</span> ui32Port, <span class="type">uint32_t</span> ui32IntFlags)</span></span><br></pre></td></tr></table></figure>

<p>功能：清除指定中断源标志<br>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags ：被清除的中断源中断屏蔽位<br>发生中断后，对应的中断标志位置1，进入中断服务函数，在服务函数中务必清除中断标志，否则程序将不停地进入中断服务函数</p>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/tm4c123gh6pm.h&quot;</span>				<span class="comment">//Register Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> delay_ms(n); SysCtlDelay(n*(SysCtlClockGet()/3000));</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ButtonsInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_interrupt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使能时钟</span></span><br><span class="line">	SysCtlClockSet(SYSCTL_SYSDIV_4|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);</span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置PF1/PF3为输出,点亮绿灯（PF3）</span></span><br><span class="line">	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE,GPIO_PIN_3|GPIO_PIN_1);</span><br><span class="line">	GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_3|GPIO_PIN_1,<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//按键使能</span></span><br><span class="line">	ButtonsInit();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		;	</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************************</span></span><br><span class="line"><span class="comment">*函数名: ButtonsInit</span></span><br><span class="line"><span class="comment">*描	 述：按键初始化函数</span></span><br><span class="line"><span class="comment">                                                                                                                                                                                                                                                                                              *输	 入：无</span></span><br><span class="line"><span class="comment">*线  路：PF0&lt;-&gt;SW2</span></span><br><span class="line"><span class="comment">	     PF4&lt;-&gt;SW1</span></span><br><span class="line"><span class="comment">******************************************************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ButtonsInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使能PF时钟</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置PF4为输入，上拉（没按就是高电平，按下就是低电平）</span></span><br><span class="line">	GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方向为输入</span></span><br><span class="line">	GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);<span class="comment">//推挽上拉</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//PF4配置为下降沿中断</span></span><br><span class="line">	GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_FALLING_EDGE);<span class="comment">//下降沿</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//给PF组注册一个中断函数</span></span><br><span class="line">	GPIOIntRegister(GPIO_PORTF_BASE, io_interrupt);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开启PF4的中断</span></span><br><span class="line">	GPIOIntEnable(GPIO_PORTF_BASE, GPIO_INT_PIN_4);</span><br><span class="line">	IntEnable(INT_GPIOF);</span><br><span class="line">	IntMasterEnable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************************</span></span><br><span class="line"><span class="comment">*函数名: io_interrupt</span></span><br><span class="line"><span class="comment">*描	 述：GPIO外部中断处理函数</span></span><br><span class="line"><span class="comment">*输	 入：无</span></span><br><span class="line"><span class="comment">*线  路：PF4&lt;-&gt;SW1</span></span><br><span class="line"><span class="comment">******************************************************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">io_interrupt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> trigger=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取中断状态</span></span><br><span class="line">	<span class="type">uint32_t</span> s = GPIOIntStatus(GPIO_PORTF_BASE, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//清除发生的中断标志</span></span><br><span class="line"> 	GPIOIntClear(GPIO_PORTF_BASE, s);</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">if</span>((s&amp;GPIO_PIN_4) == GPIO_PIN_4)</span><br><span class="line">  	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4));<span class="comment">//等待按键松开</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!trigger)</span><br><span class="line">			trigger=<span class="number">1</span>,GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_3|GPIO_PIN_1,<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//点亮红灯（PF1）</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			trigger=<span class="number">0</span>,GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_3|GPIO_PIN_1,<span class="number">1</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//点亮绿灯（PF3）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><h2 id="1-Tiva控制器的UART特征"><a href="#1-Tiva控制器的UART特征" class="headerlink" title="1.Tiva控制器的UART特征"></a>1.Tiva控制器的UART特征</h2><p> <img src="https://img-blog.csdnimg.cn/20190712154843399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="2-UART结构图"><a href="#2-UART结构图" class="headerlink" title="2.UART结构图"></a>2.UART结构图</h2><p> <img src="https://img-blog.csdnimg.cn/20190712155058934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p>UART和引脚的复用映射表</p>
<p> 这个表非常重要，编程时要根据这个参考 </p>
<p>（TM4C123GXL板子：串口0的接收端不能用，串口1正常，串口2也不正常，涉及到芯片部分IO解锁的东西）</p>
<p> <img src="https://img-blog.csdnimg.cn/20190712155235173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="3-FIFO操作"><a href="#3-FIFO操作" class="headerlink" title="3.FIFO操作"></a>3.FIFO操作</h2><p> 看来许多人还没有真正理解FIFO的作用和优点，仍然停留在每收发一个字符就要中断处理一次的老思路上。UART收发FIFO主要是为了解决收发中断过于频繁而导致的CPU效率不高的问题。</p>
<p>　　FIFO的必要性。在进行UART通信时，中断方式比轮询方式要简便且效率高。但是，如果没有收发FIFO，则每传输一个数据（5～8位）都要中断处理一次，效率仍然不高。如果有了收发FIFO，则可以在连续收发若干个数据（可多至14个）后才产生一次中断，然后一起处理。这就大大提高了收发效率。</p>
<p>　　接收超时问题。如果没有接收超时功能，则在对方已经发送完毕而接收FIFO未填满时并不会触发中断（FIFO满才会触发中断），结果造成最后接收的有效数据得不到处理的问题。有了接收超时功能后，如果接收FIFO未填满而对方发送已经停，则在不超过3个数据的接收时间内就会触发超时中断，因此数据会照常得到处理。</p>
<p>　　总之，FIFO的设计是优秀而合理的，它已经帮你想到了收发过程中存在的任何问题，只要初始化配置UART后，就可以放心收发了，FIFO和中断例程会自动搞定一切！</p>
<p>　　完全不必要担心FIFO大大减少了中断产生的次数而“可能”造成数据丢失的问题！</p>
<p>　　发送时，只要发送FIFO不满，数据只管往里连续放，放完后就直接退出发送子程序。随后，FIFO真正发送完成后会自动产生中断，通知主程序说：我已经完成真正的发送。</p>
<p>　　接收时，如果对方是连续不间断发送，则填满FIFO后会以中断的方式通知主程序说：现在有一批数据来了，请处理。</p>
<p>　　如果对方是间断性发送，也不要紧，当间隔时间过长时（2～3个字符传输时间），也会产生中断，这次是超时中断，通知主程序说：对方可能已经发送完毕，但FIFO未满，也请处理。</p>
<p>每个UART有两个16x8的缓冲区，一个用来发送，一个用来接收</p>
<p>FIFO状态通过UART标志寄存器UARTFR和UART接收状态寄存器（UARTRSR）显示。硬件监视空、满和溢出情况。</p>
<p>FIFO产生中断的触发条件由 UART中断FIFO深度选择（UARTIFLS）控制。两个FIFO可以单独配置为不同的电平情况下触发中断。可以选择如下配置：1&#x2F;8、1&#x2F;4、1&#x2F;2、3&#x2F;4、7&#x2F;8。（例如：1&#x2F;4代表连续FIFO装入16*1&#x2F;4&#x3D;4个字节产生一个接受中断）</p>
<p>复位后FIFO都是禁用的并作为1字节的保留寄存器，FIFO中断默认为两个都是1&#x2F;2选项。通过UARTLCRH的FEN位启用FIFO。</p>
<p>注意：关于复位后FIFO是默认使能还是禁用，似乎TI手册之间有矛盾，总之不要用默认设置，自己手动设置一下吧<br>以下内容来自ti的getting start手册</p>
<p> <img src="https://img-blog.csdnimg.cn/20190712164442900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="相关库函数-1"><a href="#相关库函数-1" class="headerlink" title="相关库函数"></a>相关库函数</h3><p> \1. UARTConfigSet()<br>　　配置UART，例如：<br>  &#x2F;&#x2F; 配置UART2：波特率9600，数据位8，停止位1，无校验<br>  UARTConfigSet(UART2_BASE, 9600, UART_CONFIG_WLEN_8 |<br>                  UART_CONFIG_STOP_ONE |<br>                  UART_CONFIG_PAR_NONE);</p>
<p>\2. UARTFIFOLevelSet()<br>　　设置UART收发FIFO的深度，可以设置的深度有2、4、8、12、14</p>
<p>\3. UARTSpaceAvail()<br>　　确认在发送FIFO里是否有可利用的空间。</p>
<p>\4. UARTCharsAvail()<br>　　确认在接收FIFO里是否存在字符。</p>
<p>\5. UARTCharPutNonBlocking()<br>　　该函数要与UARTSpaceAvail()配合使用，如果已确认发送FIFO里有可用空间，则将字符直接放入发送FIFO，不等待。</p>
<p>\6. UARTCharGetNonBlocking()<br>　　该函数要与UARTCharsAvail()配合使用，如果已确认接收FIFO里有字符，则直接从接收FIFO里读取字符，不等待。</p>
<p>\7. UARTCharPut()<br>　　将字符放到发送FIFO里，如果没有可用空间则一直等待。</p>
<p>\8. UARTCharGet()<br>　　从接收FIFO里读取字符，如果没有字符则一直等待。</p>
<p>\9. UARTIntEnable()<br>　　使能一个或多个UART中断，例如：<br>  &#x2F;&#x2F; 同时使能接收中断(接收FIFO溢出)和接收超时中断<br>  UARTIntEnable(UART2_BASE, UART_INT_RX | UART_INT_RT); </p>
<h2 id="4-中断"><a href="#4-中断" class="headerlink" title="4.中断"></a>4.中断</h2><p> 如下介绍，建议结合相关的寄存器看，包括<code>UARTCTL寄存器</code>和<code>UARTIFLS寄存器</code> </p>
<p> <img src="https://img-blog.csdnimg.cn/20190712163004163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<ul>
<li>接收超时中断：当FIFO不是空的，并且在32位期间没有接收到进一步的数据时触发</li>
<li>接收中断：如果开启FIFO，当收数据&gt;&#x3D;FIFO深度时触发；否则每次接收到数据都触发</li>
<li>发送中断：如果开启FIFO，当FIFO中数据&lt;&#x3D;FIFO深度时触发；否则在FIFO中没有数据时触发</li>
</ul>
<h2 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5.示例代码"></a>5.示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*官方例程1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//时钟分频  400/2/4=50</span></span><br><span class="line">	SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使能GPIOA,UART0外设</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO模式配置 PA0--RX  PA1--TX</span></span><br><span class="line">	GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">	GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO的UART模式</span></span><br><span class="line">	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//UART协议配置 波特率115200 8位 1停止位 无校验位</span></span><br><span class="line">	UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), <span class="number">115200</span>,(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));</span><br><span class="line">	</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">	UARTCharPut(UART0_BASE, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UARTCharsAvail(UART0_BASE)) <span class="comment">//判断FIFO内是否有数据</span></span><br><span class="line">			UARTCharPut(UART0_BASE, UARTCharGet(UART0_BASE));</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">//UARTCharPut：等待从指定端口发送字符</span></span><br><span class="line">    <span class="comment">//UARTCharGet：等待来自端口的字符（FIFO）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Uart1_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="comment">//使能GPIOB,UART1外设</span></span><br><span class="line">  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);	</span><br><span class="line">  SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line">  </span><br><span class="line">     <span class="comment">//GPIO模式配置 PA0--RX  PA1--TX</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PB0_U1RX);</span><br><span class="line">    GPIOPinConfigure(GPIO_PB1_U1TX);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO的UART模式</span></span><br><span class="line">  GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">	</span><br><span class="line">     <span class="comment">//UART协议配置 波特率115200 8位 1停止位 无校验位</span></span><br><span class="line">	UARTConfigSetExpClk(UART1_BASE, SysCtlClockGet(), <span class="number">115200</span>,(UART_CONFIG_WLEN_8|UART_CONFIG_STOP_ONE|UART_CONFIG_PAR_NONE));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//禁用FIFO，默认FIFO Level为4/8 寄存器满8字节后产生中断，禁用后接收1位就产生中断</span></span><br><span class="line">	UARTFIFODisable(UART1_BASE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使能UART接收中断</span></span><br><span class="line">  UARTIntEnable(UART1_BASE,UART_INT_RX);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//UART中断地址注册</span></span><br><span class="line">  UARTIntRegister(UART1_BASE,UART1_IRQHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优先级分组</span></span><br><span class="line">  IntPrioritySet(INT_UART1, USER_INT5);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//UART中断函数</span></span><br><span class="line">&#123;				</span><br><span class="line">  <span class="comment">//获取中断标志 原始中断标志 不屏蔽中断标志		</span></span><br><span class="line">  <span class="type">uint32_t</span> flag = UARTIntStatus(UART1_BASE,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//清除中断标志</span></span><br><span class="line">  UARTIntClear(UART1_BASE,flag);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//判断FIFO是否还有数据		</span></span><br><span class="line">  <span class="keyword">while</span>(UARTCharsAvail(UART1_BASE))		</span><br><span class="line">  &#123;			</span><br><span class="line">    <span class="type">char</span> ch = UARTCharGet(UART1_BASE);</span><br><span class="line"><span class="comment">//		UARTCharPut(UART1_BASE, 0x05);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><p> TM4C123GH6PM控制器包含两个pwm模块，每个模块由4个pwm发生器和一个控制模块组成，每个发生器可以产生2个pwm信号，<strong>一共可以输出16个</strong>pwm信号（<strong>同一发生器产生的两个信号的周期是一致的，但占空比可以设为不同的</strong>） </p>
<h2 id="PWM发生器特点"><a href="#PWM发生器特点" class="headerlink" title="PWM发生器特点"></a>PWM发生器特点</h2><p> <img src="https://img-blog.csdnimg.cn/20190710181953400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="人生自古谁无死，留取丹心照汗青"> </p>
<h2 id="PWM结构图"><a href="#PWM结构图" class="headerlink" title="PWM结构图"></a>PWM结构图</h2><p> <img src="https://img-blog.csdnimg.cn/20190710182204486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> 其中一个发生器的细节 </p>
<p> <img src="https://img-blog.csdnimg.cn/20190710182233264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="PWM引脚映射情况"><a href="#PWM引脚映射情况" class="headerlink" title="PWM引脚映射情况"></a>PWM引脚映射情况</h2><p> <strong>它记录了在硬件层面上，哪些pwm信号输出连接到哪些引脚</strong>，编程时需要对照查看 </p>
<p> <img src="https://img-blog.csdnimg.cn/20190710182803366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="PWM模块时钟来源"><a href="#PWM模块时钟来源" class="headerlink" title="PWM模块时钟来源"></a>PWM模块时钟来源</h2><p> <img src="https://img-blog.csdnimg.cn/20190708100659281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> 查看原理图，可见pwm模块时钟来源于经过<code>USEPWMDIV</code>分频的系统时钟，所有pwm信号的时钟频率都是这个。 </p>
<h2 id="PWM信号产生过程"><a href="#PWM信号产生过程" class="headerlink" title="PWM信号产生过程"></a>PWM信号产生过程</h2><p>（1）类似stm32，TM4C的pwm利用定时器实现(不过TM4C的pwm模块中有自带的定时器，不需要想stm32那样使用timer外设)，可以选择三种计数模式</p>
<p>向上计数（pwm信号右对齐）<br>向下计数（pwm信号左对齐）<br>上下计数（pwm信号中间对齐）<br>（2）每个pwm信号发生器，可以配置两个pwm比较器（类似stm32中的ccrx），比较器根据设定的比较值和当前计数值输出高电平脉冲<br>（3）所有计数器、比较器的信息会被pwm信号发生器检测，并生成对应的pwm波</p>
<h2 id="PWM配置过程及示例代码"><a href="#PWM配置过程及示例代码" class="headerlink" title="PWM配置过程及示例代码"></a>PWM配置过程及示例代码</h2><p>配置一个PWM发生器，频率25KHz，信号0（MnPWM0）占空比25%，信号1（MnPWM1）占空比75%，假定系统时钟频率为20M<br>使能PWM时钟 SysCtlPeripheralEnable()</p>
<p>使能被复用引脚的时钟 SysCtlPeripheralEnable()</p>
<p>使能引脚复用PWM功能 GPIOPinTypePWM()</p>
<p>将PWM信号分配到合适的引脚上 GPIOPinConfigure()</p>
<p>使能PWM时钟，设置PWM分频器为2分频（PWM时钟源为10M） SysCtlPWMClockSet();</p>
<p>配置为向下计数，参数立即更新模式 PWMGenConfigure()</p>
<p>设置周期时间（定时器计数范围），目标频率25K，PWM频率10M，则每一个信号周期有400个PWM周期，故装载值设为400-1（0到399共400个值） PWMGenPeriodSet()</p>
<p>设置信号0占空比25%，信号1占空比75% PWMPulseWidthSet()</p>
<p>启动PWM发生器的定时器 PWMGenEnable()</p>
<p>使能PWM输出 PWMOutputState()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/tm4c123gh6pm.h&quot;</span>				<span class="comment">//Register Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> delay_ms(n); SysCtlDelay(n*(SysCtlClockGet()/3000));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************************</span></span><br><span class="line"><span class="comment">*函数名: PWMInit()</span></span><br><span class="line"><span class="comment">*描	 述：PWM初始化函数</span></span><br><span class="line"><span class="comment">*输	 入：无</span></span><br><span class="line"><span class="comment">*线  路：PF2&lt;-&gt;M1PWM6</span></span><br><span class="line"><span class="comment">				 PF4&lt;-&gt;M1PWM7</span></span><br><span class="line"><span class="comment">******************************************************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWMInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//配置PWM时钟（设置USEPWMDIV分频器）</span></span><br><span class="line">	SysCtlPWMClockSet(SYSCTL_PWMDIV_1);																									<span class="comment">//PWM时钟 16M</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能时钟</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);			<span class="comment">//使能PWM模块1时钟																		</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);		<span class="comment">//使能GPIOF时钟																		</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使能引脚复用PWM功能</span></span><br><span class="line">	GPIOPinTypePWM(GPIO_PORTF_BASE,GPIO_PIN_2);</span><br><span class="line">	GPIOPinTypePWM(GPIO_PORTF_BASE,GPIO_PIN_3);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//PWM信号分配</span></span><br><span class="line">	GPIOPinConfigure(GPIO_PF2_M1PWM6);					<span class="comment">//PF2-&gt;PWM模块1信号6																							</span></span><br><span class="line">	GPIOPinConfigure(GPIO_PF3_M1PWM7);					<span class="comment">//PF3-&gt;PWM模块1信号7																								</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置PWM发生器</span></span><br><span class="line">	<span class="comment">//模块1-&gt;发生器3-&gt;上下计数，不同步</span></span><br><span class="line">	PWMGenConfigure(PWM1_BASE,PWM_GEN_3,PWM_GEN_MODE_UP_DOWN|PWM_GEN_MODE_NO_SYNC);	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置PWM周期</span></span><br><span class="line">	PWMGenPeriodSet(PWM1_BASE,PWM_GEN_3,<span class="number">64000</span>);			<span class="comment">//64*10^3/16/10^6=4ms																			</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置PWM占空比</span></span><br><span class="line">	PWMPulseWidthSet(PWM1_BASE,PWM_OUT_6,PWMGenPeriodGet(PWM1_BASE, PWM_GEN_3)*<span class="number">0.01</span>);		<span class="comment">//比较值为四分之一总计数值，25%</span></span><br><span class="line">	PWMPulseWidthSet(PWM1_BASE,PWM_OUT_7,PWMGenPeriodGet(PWM1_BASE, PWM_GEN_3)*<span class="number">0.01</span>);		<span class="comment">//比较值为四分之三总计数值，75%</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能PWM模块1输出</span></span><br><span class="line">	PWMOutputState(PWM1_BASE,PWM_OUT_6_BIT,<span class="literal">true</span>);</span><br><span class="line">	PWMOutputState(PWM1_BASE,PWM_OUT_7_BIT,<span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使能PWM发生器</span></span><br><span class="line">	PWMGenEnable(PWM1_BASE,PWM_GEN_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************************</span></span><br><span class="line"><span class="comment">*函数名: SetDuty(uint32_t ui32Base,uint32_t ui32PWMOut,float duty)</span></span><br><span class="line"><span class="comment">*描	 述：PWM初始化函数</span></span><br><span class="line"><span class="comment">*输	 入：PWM模块编号、信号编号、占空比</span></span><br><span class="line"><span class="comment">******************************************************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDuty</span><span class="params">(<span class="type">uint32_t</span> ui32Base,<span class="type">uint32_t</span> ui32PWMOut,<span class="type">float</span> duty)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint32_t</span> ui32Gen;</span><br><span class="line">		<span class="type">uint32_t</span> ui32OutBits;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">switch</span>(ui32PWMOut)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_0:	ui32Gen=PWM_GEN_0,ui32OutBits=PWM_OUT_0_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_1:	ui32Gen=PWM_GEN_0,ui32OutBits=PWM_OUT_1_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_2:	ui32Gen=PWM_GEN_1,ui32OutBits=PWM_OUT_2_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_3:	ui32Gen=PWM_GEN_1,ui32OutBits=PWM_OUT_3_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_4:	ui32Gen=PWM_GEN_2,ui32OutBits=PWM_OUT_4_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_5:	ui32Gen=PWM_GEN_2,ui32OutBits=PWM_OUT_5_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_6:	ui32Gen=PWM_GEN_3,ui32OutBits=PWM_OUT_6_BIT;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PWM_OUT_7:	ui32Gen=PWM_GEN_3,ui32OutBits=PWM_OUT_7_BIT;	<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//配置占空比</span></span><br><span class="line">    PWMPulseWidthSet(ui32Base, ui32PWMOut, PWMGenPeriodGet(ui32Base, ui32Gen)*duty);</span><br><span class="line">    PWMOutputState(ui32Base, ui32OutBits, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//使能发生器模块</span></span><br><span class="line">    PWMGenEnable(ui32Base, ui32Gen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SysCtlClockSet(SYSCTL_SYSDIV_1|SYSCTL_USE_OSC|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);		<span class="comment">//系统时钟16M</span></span><br><span class="line">	PWMInit();</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> duty1=<span class="number">0.1</span>,duty2=<span class="number">0.9</span>;</span><br><span class="line">	<span class="type">float</span> d=<span class="number">0.01</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SetDuty(PWM1_BASE,PWM_OUT_6,duty1);</span><br><span class="line">		SetDuty(PWM1_BASE,PWM_OUT_7,duty2);</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		duty1+=d;</span><br><span class="line">		duty2-=d;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(duty1&gt;=<span class="number">0.95</span> &amp;&amp; duty2&lt;=<span class="number">0.05</span>)</span><br><span class="line">			d=<span class="number">-0.01</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(duty2&gt;=<span class="number">0.95</span> &amp;&amp; duty1&lt;=<span class="number">0.05</span>)</span><br><span class="line">			d=<span class="number">0.01</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="PWM-Init"><a href="#PWM-Init" class="headerlink" title="PWM_Init"></a>PWM_Init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">  SysCtlPWMClockSet(SYSCTL_PWMDIV_8); <span class="comment">// Set divider to 80M/8=10M  1/10M=0.1us  设置PWM时钟配置</span></span><br><span class="line">  SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1); <span class="comment">//启用外设（在上电时，所有外设被设置为禁用），此处启用外设PWM1</span></span><br><span class="line">  SysCtlDelay(<span class="number">2</span>); <span class="comment">//启用外设后插入几个周期，使得时钟完全激活  </span></span><br><span class="line">  SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); <span class="comment">// 此处使能外设GPIOF</span></span><br><span class="line"></span><br><span class="line">  SysCtlDelay(<span class="number">2</span>);<span class="comment">//启用外设后插入几个周期，使得时钟完全激活 </span></span><br><span class="line">  <span class="comment">// 使用备用功能</span></span><br><span class="line">  GPIOPinConfigure(GPIO_PF2_M1PWM6);<span class="comment">//此处将M1PWM6复用到PF2引脚</span></span><br><span class="line">  GPIOPinConfigure(GPIO_PF3_M1PWM7);<span class="comment">//此处将M1PWM7复用到PF3引脚</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用引脚与PWM外设</span></span><br><span class="line">  GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);<span class="comment">//M1PWM6 PF2</span></span><br><span class="line">  GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);<span class="comment">//M1PWM7 PF3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置PWM发生器倒计时模式与即时更新的参数</span></span><br><span class="line">  PWMGenConfigure(PWM1_BASE, PWM_GEN_2, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line">  PWMGenConfigure(PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置PWM发生器的周期</span></span><br><span class="line">  PWMGenPeriodSet(PWM1_BASE, PWM_GEN_2, <span class="number">1000</span>); <span class="comment">// Set the period</span></span><br><span class="line">  PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, <span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//使能PWM发生器的定时/计数器  </span></span><br><span class="line">  PWMGenEnable(PWM1_BASE, PWM_GEN_2);</span><br><span class="line">  PWMGenEnable(PWM1_BASE, PWM_GEN_3);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使能PWM输出</span></span><br><span class="line">  PWMOutputState(PWM1_BASE, PWM_OUT_6_BIT | PWM_OUT_7_BIT , <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SysCtlPWMClockSet(SYSCTL_PWMDIV_8);</span><br><span class="line"><span class="comment">// 设置PWM时钟配置</span></span><br><span class="line"> SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1); </span><br><span class="line"><span class="comment">//启用外设（在上电时，所有外设被设置为禁用），此处启用外设PWM1</span></span><br><span class="line"> SysCtlDelay(<span class="number">2</span>); </span><br><span class="line"><span class="comment">//启用外设后插入几个周期，使得时钟完全激活 （该延时没有精确的时间划分）</span></span><br><span class="line">GPIOPinConfigure(GPIO_PF2_M1PWM6);</span><br><span class="line"><span class="comment">//函数配置引脚复用器  此处将M1PWM复用到PF2引脚</span></span><br><span class="line"> GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line"><span class="comment">//此功能不能将任何引脚转换为PWM引脚，它只配置PWM引脚以正常工作。还需要GPIOPINConfigure()函数调用来正确配置PWM函数的引脚</span></span><br><span class="line">PWMGenConfigure(PWM1_BASE, PWM_GEN_2, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"><span class="comment">//参数：PWM模块基址，PWM发生器（PWM_GEN_0，PWM_GEN_1，PWM_GEN_2，PWM_GEN_3），PWM发生器配置</span></span><br><span class="line"><span class="comment">//将PWM发生器配置为倒计时模式，并立即更新参数</span></span><br><span class="line">PWMGenPeriodSet(PWM1_BASE, PWM_GEN_2, <span class="number">1000</span>); <span class="comment">//配置PWM发生器的周期  参数：PWM模块基址，要修改的PWM发生器，指定PWM发生器输出的周期</span></span><br><span class="line">PWMGenEnable(PWM1_BASE, PWM_GEN_2);<span class="comment">//使能PWM发生器的定时/计数器</span></span><br><span class="line">  PWMOutputState(PWM1_BASE, PWM_OUT_6_BIT | PWM_OUT_7_BIT , <span class="literal">true</span>);<span class="comment">//使能或者禁用PWM输出</span></span><br></pre></td></tr></table></figure>

<h2 id="PWM-Set"><a href="#PWM-Set" class="headerlink" title="PWM_Set"></a>PWM_Set</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Set</span><span class="params">(<span class="type">uint16_t</span> motor1,<span class="type">uint16_t</span> motor2)</span></span><br><span class="line">&#123;</span><br><span class="line">  PWMPulseWidthSet(PWM1_BASE,PWM_OUT_6,motor1);     <span class="comment">//PF2</span></span><br><span class="line">  PWMPulseWidthSet(PWM1_BASE,PWM_OUT_7,motor2);     <span class="comment">//PF3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PWMPulseWidthSet(PWM1_BASE,PWM_OUT_6,motor1);</span><br><span class="line"><span class="comment">//设置指定PPWM输出的脉冲宽度</span></span><br></pre></td></tr></table></figure>

<h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><h2 id="输入捕获引脚映射关系"><a href="#输入捕获引脚映射关系" class="headerlink" title="输入捕获引脚映射关系"></a>输入捕获引脚映射关系</h2><p> <img src="https://img-blog.csdnimg.cn/20190712185612222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20190712185639520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="边沿计数模式"><a href="#边沿计数模式" class="headerlink" title="边沿计数模式"></a>边沿计数模式</h2><p> 在该模式中，TimerA或TimerB被配置为能够捕获外部输入脉冲边沿事件的递增&#x2F;减计数器。共有3种边沿事件类型：正边沿、负边沿、双边沿 </p>
<p>工作过程是：<br>（1）减计数：设置装载值Preload，并预设一个匹配值Match（应当小于装载值）；计数使能后，在特定的CCP管脚每输入1个脉冲（正边沿、负边沿或双边沿有效），计数值就减1；当计数值与匹配值Match相等时停止运行（若使能中断，这时会被触发）。定时器自动重装载Preload值，但如果需要再次捕获外部脉冲，则要重新进行配置。<br>（2）加计数：设置匹配值Match；计数使能后，在特定的CCP管脚每输入1个脉冲（正边沿、负边沿或双边沿有效），计数值就加1；当计数值与匹配值Match相等时停止运行（若使能中断，这时会被触发）。定时器自动清0并自动开始捕获外部脉冲计数，不需要重新进行配置</p>
<p> <img src="https://img-blog.csdnimg.cn/20190712192258596.png" alt="在这里插入图片描述"> </p>
<p>注意：</p>
<p>配置为边沿计数模式时，定时器必须配置为拆分模式，64-bit未拆分模式下不可以用Capture<br>此模式下，8bit的定时器预分频寄存器(Prescaler)不再作为分频器使用，定时器频率和系统时钟频率相同， 预分频寄存器的8bit空间作为计数范围的扩展，增加到定时器计数器的高位。也就是说32&#x2F;64位定时器的输入捕获计数范围为24&#x2F;48bit<br>配置过程：<br>GPIO设置：</p>
<p>1.GPIOPinConfigure 进行引脚到TnCCPm的信号映射<br>2.GPIOPinTypeTimer 配置引脚到定时器模式<br>3.GPIOPadConfigSet 配置其他引脚参数</p>
<p>配置定时器模块为捕捉-边沿计数模式：</p>
<ol start="4">
<li>TimerConfigure 配置定时器模式。注意第二个参数一定是TIMER_CFG_SPLIT_PAIR和一下之一相或<br>（1）TIMER_CFG_A_CAP_COUNT 模块A捕捉-边沿减计数模式<br>（2）TIMER_CFG_A_CAP_COUNT_UP 模块A捕捉-边沿加计数模式<br>（3）TIMER_CFG_B_CAP_COUNT 模块B捕捉-边沿减计数模式<br>（4）TIMER_CFG_B_CAP_COUNT_UP 模块B捕捉-边沿加计数模式</li>
</ol>
<p>设置要捕捉的边沿：</p>
<ol start="5">
<li>TimerControlEvent</li>
</ol>
<p>设置计数范围：</p>
<ol start="6">
<li>TimerMatchSet设置加&#x2F;减计数结束值</li>
<li>TimerLoadSet设置减计数起始值</li>
</ol>
<p>中断设置：</p>
<ol start="8">
<li>TimerIntRegister 注册中断服务函数</li>
<li>TimerIntEnable 源级中断使能，这里注意配置中断类型<br>（1）TIMER_CAPA_MATCH – 模块A计数到达预设值<br>（2）TIMER_CAPB_MATCH – 模块B计数到达预设值</li>
<li>IntEnable 中断控制器级中断使能</li>
<li>IntMasterEnable处理器级中断使能</li>
</ol>
<p>启动定时器模块：</p>
<ol start="12">
<li>TimerEnable</li>
</ol>
<h2 id="边沿计时模式"><a href="#边沿计时模式" class="headerlink" title="边沿计时模式"></a>边沿计时模式</h2><p>简介：在该模式中，TimerA&#x2F;B被配置为自由运行的16位递减计数器，允许在输入信号的上升沿或下降沿捕获事件。</p>
<p>工作过程是：设置装载值（默认为0xFFFF）、捕获边沿类型；计数器被使能后开始自由运行，从装载值开始递减计数（或从0开始递增计数），计数到0（或装载值）时重装（或清零），继续计数；如果从CCP管脚上出现有效的输入脉冲边沿事件，则当前计数值被自动复制到一个特定的寄存器里，该值会一直保存不变，直至遇到下一个有效输入边沿时被刷新。为了能够及时读取捕获到的计数值，应当使能边沿事件捕获中断，并在中断服务函数里读取。</p>
<p> <img src="https://img-blog.csdnimg.cn/20190712193416887.png" alt="在这里插入图片描述"> </p>
<p>注意：</p>
<p>配置为边沿计时模式时，定时器必须配置为拆分模式，64-bit未拆分模式下不可以用Capture<br>此模式下，8bit的定时器预分频寄存器(Prescaler)不再作为分频器使用，定时器频率和系统时钟频率相同， 预分频寄存器的8bit空间作为计数范围的扩展，增加到定时器计时器的高位。也就是说32&#x2F;64位定时器的输入捕获计时范围为24&#x2F;48bit<br>配置过程：和计数模式基本一样，仅有以下区别<br>需要配置定时器模块为捕捉-边沿计时模式</p>
<p>TimerConfigure第二个参数是TIMER_CFG_SPLIT_PAIR和一下之一相或<br>（1）TIMER_CFG_A_CAP_TIME 模块A捕捉-边沿减计时模式<br>（2）TIMER_CFG_A_CAP_TIME <em>UP 模块A捕捉-边沿加计时模式<br>（3）TIMER_CFG_B_CAP</em> TIME 模块B捕捉-边沿减计时模式<br>（4）TIMER_CFG_B_CAP_ TIME _UP 模块B捕捉-边沿加计时模式<br>设置计时范围</p>
<ol start="2">
<li>TimerLoadSet无论加计时还是减计时，都用这个函数设置Preload值</li>
</ol>
<p>中断设置</p>
<ol start="3">
<li>TimerIntEnable的中断类型参数变为以下二者之一<br>（1） TIMER_CAPA_EVENT 模块A发生捕获事件<br>（2） TIMER_CAPB_EVENT 模块B发生捕获事件</li>
</ol>
<h2 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timer0A输入捕获，脉冲从PB6输入（PF0作T0CCP0）</span></span><br><span class="line"><span class="type">int</span> timer0A_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">		<span class="comment">// 启用Timer0模块   </span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 启用GPIO_F作为脉冲捕捉脚   </span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 配置GPIO脚为使用Timer4捕捉模式   </span></span><br><span class="line">    GPIOPinConfigure(GPIO_PB6_T0CCP0);   </span><br><span class="line">    GPIOPinTypeTimer(GPIO_PORTB_BASE, GPIO_PIN_6); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为管脚配置弱上拉模式（捕获下降沿，配置为上拉）</span></span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTB_BASE, GPIO_PIN_6, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 配置使用Timer4的TimerA模块为边沿触发加计数模式</span></span><br><span class="line">    TimerConfigure(TIMER0_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_COUNT_UP);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 使用下降沿触发   </span></span><br><span class="line">    TimerControlEvent(TIMER0_BASE, TIMER_A, TIMER_EVENT_NEG_EDGE); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置计数范围为0~9</span></span><br><span class="line">    TimerMatchSet(TIMER0_BASE, TIMER_A, <span class="number">10</span><span class="number">-1</span>);		<span class="comment">//理论匹配周期10^-4*10=0.001s</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 注册中断处理函数以响应触发事件   </span></span><br><span class="line">    TimerIntRegister(TIMER0_BASE, TIMER_A, Timer0AIntHandler);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 系统总中断开   </span></span><br><span class="line">    IntMasterEnable();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 时钟中断允许，中断事件为Capture模式中边沿触发，计数到达预设值   </span></span><br><span class="line">    TimerIntEnable(TIMER0_BASE, TIMER_CAPA_MATCH);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// NVIC中允许定时器A模块中断   </span></span><br><span class="line">    IntEnable(INT_TIMER0A);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 启动捕捉模块  </span></span><br><span class="line">    TimerEnable(TIMER0_BASE, TIMER_A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务函数 理论周期：0.001s</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0AIntHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TimerIntClear(TIMER0_BASE, TIMER_CAPA_MATCH);</span><br><span class="line">	timer0A_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><h2 id="单次运行模式和连续运行模式"><a href="#单次运行模式和连续运行模式" class="headerlink" title="单次运行模式和连续运行模式"></a>单次运行模式和连续运行模式</h2><p> 定时器的基本功能为计数(包括加计数和减计数两种)，Stellaris LM4F中以系统时钟为计数节拍(当计数器被拆分使用时可以使用预分频功能，为了简单起见这里不作讨论)。当加计数时，计数器由零开始，逐步加一，直到到达用户预设值；减计数则由某一用户预设值开始，逐步减一，直到计数为零。每当计数完成，则会置相应的状态位(包括中断)，提示计时完成。</p>
<p>单次运行与连续运行工作时没有区别，不同的是单次运行在完成一次计时后会自动停止，连续模式下定时器会自动从计数起点开始(根据计数方向为零或用户设定值)继续计时。 </p>
<h2 id="定时器程序设置"><a href="#定时器程序设置" class="headerlink" title="定时器程序设置"></a>定时器程序设置</h2><p>1.启用时钟模块</p>
<p> 使用SysCtlPeripheralEnable函数启用相应的定时器模块。</p>
<p>程序示例：<br>     SysCtlPeripheralEnable(SYSCTL_PERIPH_WTIMER0);</p>
<p>在StellarisWare中，32&#x2F;16-bit定时器模块为TIMER，64&#x2F;32-bit定时器模块为WTIMER (Wide Timer)。除了名字不同、计数范围不同外没有其它区别。 </p>
<p>2.设置时钟模块工作模式</p>
<p> 使用TimerConfigure函数对定时器模块的工作模式进行设置，将其设置为定时器功能。</p>
<p>程序示例：<br>     TimerConfigure(TIMER0_BASE,TIMER_CFG_ONE_SHOT);<br>     TimerConfigure(WTIMER2_BASE,TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_ONE_SHOT |TIMER_CFG_B_PERIODIC);</p>
<p>在不拆分的情况下，可以用下面参数中的一个将模块设置成所需的定时器模式：<br>     TIMER_CFG_ONE_SHOT – 单次减计数模式<br>     TIMER_CFG_ONE_SHOT_UP – 单次加计数模式<br>     TIMER_CFG_PERIODIC – 连续减计数模式<br>     TIMER_CFG_PERIODIC_UP – 连续加计数模式<br>     TIMER_CFG_RTC – 实时时钟模式</p>
<p>如果需要将计时器拆分，则需使用参数TIMER_CFG_SPLIT_PAIR然后用“|”号连接被拆分定时器A、B的设置。如果只使用了一个可以只设置用到的那个。拆分出来的定时器A和B的设置方法是一样的，只是函数名中各自用A和B：<br>     TIMER_CFG_A_ONE_SHOT – 定时器A单次减计数<br>     TIMER_CFG_A_ONE_SHOT_UP –定时器A单次加计数<br>     TIMER_CFG_A_PERIODIC – 定时器A连续减计数<br>     TIMER_CFG_A_PERIODIC_UP – 定时器A连续加计数</p>
<p>​     TIMER_CFG_B_ONE_SHOT – 定时器B单次减计数<br>​     TIMER_CFG_B_ONE_SHOT_UP –定时器B单次加计数<br>​     TIMER_CFG_B_PERIODIC – 定时器B连续减计数<br>​     TIMER_CFG_B_PERIODIC_UP – 定时器B连续加计数 </p>
<p>3.设置时钟的计数范围</p>
<p> 使用TimerLoadSet、TimerLoadSet64函数可以为计数设置范围。设置未拆分使用的64&#x2F;32-bit定时器模块，需要使用TimerLoadSet64函数，对其它模块、其它状况的设置使用TimerLoadSet函数。计数范围为设置值到零(加计数: 0<del>预设值，减计数: 预设值</del>0)。</p>
<p>程序示例：<br>     TimerLoadSet64(TIMER3_BASE, 80000);<br>     TimerLoadSet(WTIMER0_BASE, TIMER_B, 10000); </p>
<p>4.启动时钟</p>
<p> 使用TimerEnable函数启动定时器。可以用的参数有TIMER_A、TIMER_B和TIMER_BOTH。可以分别或同时启动A、B定时器。如果定时器没有拆分，直接使用TIMER_A即可。</p>
<p>程序示例：<br>     TimerEnable(WTIMER0_BASE, TIMER_B); </p>
<h2 id="定时器读取及中断设置"><a href="#定时器读取及中断设置" class="headerlink" title="定时器读取及中断设置"></a>定时器读取及中断设置</h2><p>1.计数值读取</p>
<p> 可以使用TimerValueGet函数和TimerValueGet64函数获得定时器当前的计数值。需要注意的是TimerValueGet64返回的是64位结果。</p>
<p>程序示例：<br>     long val &#x3D; TimerValueGet(TIMER1_BASE, TIMER_A);<br>     long long timer_val &#x3D; TimerValueGet64(WTIMER3_BASE); </p>
<p>2.中断设置</p>
<p> 一般定时器多用中断响应以满足时间要求。可以用TimerIntRegister向系统注册中断处理函数，用TimerIntEnable来允许某个定时器的中断请求。需要注意的是，在M4中还应该用IntEnable在系统层使能定时器的中断。当然，系统总中断开关也必须用IntMasterEnable使能。</p>
<p>TimerIntEnable在该模式下可以支持：<br>     TIMER_TIMA_TIMEOUT<br>     TIMER_TIMB_TIMEOUT</p>
<p>程序示例：<br>     TimerIntRegister(WTIMER0_BASE, TIMER_B, WTimer0BIntHandler);<br>     IntMasterEnable();<br>     TimerIntEnable(WTIMER0_BASE, TIMER_TIMB_TIMEOUT);<br>     IntEnable(INT_WTIMER0B);</p>
<p>在Timer中断中，需要手工清除中断标志位，可以使用如下代码：<br>     unsignedlong ulstatus &#x3D; TimerIntStatus(TIMER4_BASE, TIMER_TIMA_TIMEOUT |TIMER_TIMB_TIMEOUT);<br>     TimerIntClear(TIMER4_BASE,ulstatus); </p>
<h2 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stellaris硬件定义及StellarisWare驱动定义头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_ints.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录进入定时器中断的次数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> g_ulCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化UART的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">InitConsole</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器的中断处理函数</span></span><br><span class="line">Void <span class="title function_">WTimer0BIntHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 清除当前中断标志  </span></span><br><span class="line">    TimerIntClear(WTIMER0_BASE, TIMER_TIMB_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进入中断次数的计数  </span></span><br><span class="line">    g_ulCounter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 用来记录上次计数以判断是否计数改变</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulPrevCount = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置LM4F时钟为50MHz</span></span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使能64/32-bit的时钟模块WTIMER0   </span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_WTIMER0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化UART   </span></span><br><span class="line">    InitConsole();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印程序信息   </span></span><br><span class="line">    UARTprintf(<span class="string">&quot;32-Bit Timer Interrupt -&gt;&quot;</span>);   </span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   Timer = Wide Timer0B&quot;</span>);  </span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   Mode = Periodic&quot;</span>);   </span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   Rate = 1s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WTimer0-B模块为连续减计数   </span></span><br><span class="line">    TimerConfigure(WTIMER0_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_B_PERIODIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器的计数值，这里用系统频率值，即每秒一个中断   </span></span><br><span class="line">    TimerLoadSet(WTIMER0_BASE, TIMER_B, SysCtlClockGet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WTimer0-B的中断处理函数   </span></span><br><span class="line">    TimerIntRegister(WTIMER0_BASE, TIMER_B, WTimer0BIntHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用系统总中断开关  </span></span><br><span class="line">    IntMasterEnable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用WTimer0-B超时中断   </span></span><br><span class="line">    TimerIntEnable(WTIMER0_BASE, TIMER_TIMB_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在系统层面(NVIC)使能WTimer0-B中断   </span></span><br><span class="line">    IntEnable(INT_WTIMER0B);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动定时器 </span></span><br><span class="line">    TimerEnable(WTIMER0_BASE, TIMER_B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环等待WTimer0-B中断更新g_ulCounter计数</span></span><br><span class="line">        <span class="comment">// 若计数改变则进行UART输出       </span></span><br><span class="line">        <span class="keyword">if</span>(ulPrevCount != g_ulCounter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// UART输出计数值</span></span><br><span class="line">            UARTprintf(<span class="string">&quot;Number of interrupts: %d</span></span><br><span class="line"><span class="string">&quot;</span>, g_ulCounter);</span><br><span class="line"></span><br><span class="line">            ulPrevCount = g_ulCounter;       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//定时器0使能</span></span><br><span class="line">  SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);					</span><br><span class="line">    <span class="comment">//32位周期定时器</span></span><br><span class="line">  TimerConfigure(TIMER0_BASE,TIMER_CFG_PERIODIC);				</span><br><span class="line">    <span class="comment">//设定装载值，（80M/1000）*1/80M=1ms</span></span><br><span class="line">  TimerLoadSet(TIMER0_BASE,TIMER_A,SysCtlClockGet()/<span class="number">1000</span>);		</span><br><span class="line">    <span class="comment">//总中断使能</span></span><br><span class="line">  IntEnable(INT_TIMER0A);										</span><br><span class="line">    <span class="comment">//中断输出，设置模式</span></span><br><span class="line">  TimerIntEnable(TIMER0_BASE,TIMER_TIMA_TIMEOUT); 				</span><br><span class="line">    <span class="comment">//中断函数注册</span></span><br><span class="line">  TimerIntRegister(TIMER0_BASE,TIMER_A,TIMER0A_Handler);		</span><br><span class="line">    <span class="comment">//定时器使能开始计数</span></span><br><span class="line">  TimerEnable(TIMER0_BASE,TIMER_A); 							</span><br><span class="line">    <span class="comment">//中断优先级划分</span></span><br><span class="line">  IntPrioritySet(INT_TIMER0A,USER_INT7);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER0A_Handler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	Scheduler_Run();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除当前中断标志</span></span><br><span class="line">	TimerIntClear(TIMER0_BASE,TIMER_TIMA_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><h2 id="一、I2C接口的介绍："><a href="#一、I2C接口的介绍：" class="headerlink" title="一、I2C接口的介绍："></a>一、I2C接口的介绍：</h2><p>   内部集成电路（I2C）总线通过一个两线设计（串行数据线 SDA 和串行时钟线 SCL）来提供双向数据传输，并且与外部 I2C 器件诸如串行存储器（RAM 和 ROM），网络设备，LCD，音频发生器等联系。I2C 总线也可用于产品开发和制造的系统测试和诊断的目的。TM4C123GH6PM 微控制器提供与其他 I2C 总线上的设备交互（发送和接收）的能力。TM4C123GH6PM 控制器的 I2C 模块具有以下特点：</p>
<p> I2C 总线上的设备可被配置为主机或从机<br>— 支持一个主机或从机发送和接收数据<br>— 同时支持主机和从机操作<br> 四个 I2C 模式：<br>— 主机发送模式<br>— 主机接收模式<br>— 从机发送模式<br>— 从机接收模式<br> 四个发送速率：<br>— 标准模式（100 Kbps）<br>— 快速模式（400 Kbps）<br>— 超快速模式（1Mbps）<br>— 高速模式（3.33Mbps）<br> 时钟低超时中断的<br> 双从地址能力<br> 抗干扰<br> 主机和从机中断的产生<br>— 当主机发送或接收操作完成时（或因错误终止时），产生中断<br>— 当从机发送数据或主机需要数据或检测到起始或停止条件时，产生中断<br> 主机由仲裁和时钟同步，支持多主机，以及 7 位寻址模式</p>
<p>![1690613571472](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1690613571472.png)</p>
<h2 id="二、结构图："><a href="#二、结构图：" class="headerlink" title="二、结构图："></a>二、结构图：</h2><p> <img src="https://img-blog.csdnimg.cn/2019063015483772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI3Njc4,size_16,color_FFFFFF,t_70" alt="img"> </p>
<h2 id="三、-初始化与配置"><a href="#三、-初始化与配置" class="headerlink" title="三、 初始化与配置"></a>三、 初始化与配置</h2><p>以下例子给出如何配置 I2C 模块用于主机传输一个字节。这里假定系统时钟为 20 MHz 。</p>
<ol>
<li>在系统控制模块使用 RCGCI2C 寄存器使能 I2C 时钟。</li>
<li>通过在系统控制模块的 RCGCGPIO 寄存器为相应的 GPIO 模块使能时钟。要了解使能哪些GPIO 端口。</li>
<li>在 GPIO 模块，通过 GPIOAFSEL 寄存器位它们的复用功能使能相应的引脚。请参看表 23-4，以确定配置那个 GPOI。</li>
<li>使能 I2CSDA 引脚来配置开漏操作。</li>
<li>在 GPIOPCTL 寄存器配置 PMCn 位组为相应的引脚配置 I2C 信号。</li>
<li>向 I2CMCR 寄存器写入 0x00000010 值来初始化 I2C 主机。</li>
<li>通过写入 I2CMTPR 寄存器正确的值来设置所需的 100 Kbps 的 SCL 时钟速度。写入I2CMTPR 寄存器的值代表在一个 SCL 时钟周期中系统时钟周期数。TPR 值由以下等式确定：<br>TPR &#x3D; (System Clock&#x2F;(2*(SCL_LP + SCL_HP)<em>SCL_CLK))-1;<br>TPR &#x3D; (20MHz&#x2F;(2</em>(6+4)*100000))-1;<br>TPR &#x3D; 9向 I2CMTPR 寄存器写入 0x00000009.</li>
<li>规定主机的从机地址，下一个操作是一个发送，该发送通过向 I2CMSA 寄存器值写入0x00000076 实现。这设置了从机地址为 0x3B。</li>
<li>通过向 I2CMDR 寄存器写入所需数据将数据（位）传输到数据寄存器。</li>
<li>启动从主机到从机的数据单字节的传输是通过向 I2CMCS 寄存器写入 0x00000007 (STOP,START, RUN)实现。</li>
<li>等待直到传输完成，通过轮询 I2CMCS 寄存器的 BUSBSTY 位，直到该位被清除。</li>
<li>检测 I2CMCS 寄存器的 ERROR 位以确保传输被应答。</li>
</ol>
<h2 id="四、环路操作实验"><a href="#四、环路操作实验" class="headerlink" title="四、环路操作实验"></a>四、环路操作实验</h2><p>​      可以通过设置 I2C 主机配置（I2CMCR）寄存器的 LPBK 位将 I2C 模块放入一个内部环路模式用于诊断或调试工作。在环回模式下，来自主机的 SDA 和 SCL 信号和从机模块的 SDA 和SCL 信号绑定在一起，并允许内部的设备测试，而不必去通过 I &#x2F; O实验的验证就是通过主机发送数据-从机接收，从机发数据-主机接收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment"> *实验功能：通过环路模式实现单字节的主机/从机数据的发送和接收</span></span><br><span class="line"><span class="comment"> *时间：2019-6-30</span></span><br><span class="line"><span class="comment"> *作者：MountXing</span></span><br><span class="line"><span class="comment"> *******************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//包含一系列头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//要发送的I2C数据包的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_I2C_DATA  5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAVE_ADDRESS 0x3C</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> *初始化配置使用 UART0 外设</span></span><br><span class="line"><span class="comment"> *-UART0RX - PA0</span></span><br><span class="line"><span class="comment"> *-UART0TX - PA1</span></span><br><span class="line"><span class="comment">*****************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Console_Uart0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);     <span class="comment">//内部16M时钟</span></span><br><span class="line">    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> *配置I2C0主从机，并使用环回模式连接它们。</span></span><br><span class="line"><span class="comment"> *初始化I2C0外设</span></span><br><span class="line"><span class="comment"> *I2C0SCL - PB2</span></span><br><span class="line"><span class="comment"> *I2C0SDA - PB3</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> pui32DataTx[NUM_I2C_DATA];   <span class="comment">//发送数据缓冲区</span></span><br><span class="line">    <span class="type">uint32_t</span> pui32DataRx[NUM_I2C_DATA];   <span class="comment">//接受数据缓冲区</span></span><br><span class="line">    <span class="type">uint32_t</span> ui32Index;                   <span class="comment">//要发送数据到缓冲区的位置</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//配置外部时钟为20M</span></span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_1|SYSCTL_USE_OSC|SYSCTL_OSC_MAIN|SYSCTL_XTAL_16MHZ);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C0);   <span class="comment">//使能I2C0外设</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);  <span class="comment">//使能PB端口</span></span><br><span class="line">    <span class="comment">//配置引脚的复用功能 PB2 PB3</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PB2_I2C0SCL);           </span><br><span class="line">    GPIOPinConfigure(GPIO_PB3_I2C0SDA);</span><br><span class="line">    <span class="comment">//配置I2C引脚</span></span><br><span class="line">    GPIOPinTypeI2CSCL(GPIO_PORTB_BASE, GPIO_PIN_2);</span><br><span class="line">    GPIOPinTypeI2C(GPIO_PORTB_BASE, GPIO_PIN_3);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//I2CLoopbackEnable(I2C0_BASE);     //调用固件库的环回模式。(I2C.c固件库里没有这个函数)</span></span><br><span class="line">     HWREG(I2C0_BASE + I2C_O_MCR) |= <span class="number">0x01</span>; <span class="comment">//调用寄存器的环回模式 (改用寄存器实现)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化并使能主机模式，使用系统时钟为 I2C0 模块提供时钟频率，</span></span><br><span class="line">    <span class="comment">//主机模块传输速//率为 100Kbps</span></span><br><span class="line">    I2CMasterInitExpClk(I2C0_BASE, SysCtlClockGet(), <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使能从机模式</span></span><br><span class="line">    I2CSlaveEnable(I2C0_BASE);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置从机地址</span></span><br><span class="line">    I2CSlaveInit(I2C0_BASE, SLAVE_ADDRESS);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置主机放在总线上的地址，写入从机</span></span><br><span class="line">    I2CMasterSlaveAddrSet(I2C0_BASE, SLAVE_ADDRESS, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用uart初始化函数串口显示</span></span><br><span class="line">    Init_Console_Uart0();</span><br><span class="line">    UARTprintf(<span class="string">&quot;I2C 回送例子---&gt;&quot;</span>);</span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   模式 = I2C0&quot;</span>);</span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   模式 = 单独的发送/接收&quot;</span>);</span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">   比率 = 100kbps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据初始化发送.</span></span><br><span class="line">    pui32DataTx[<span class="number">0</span>] = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    pui32DataTx[<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    pui32DataTx[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pui32DataTx[<span class="number">3</span>] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">    pui32DataTx[<span class="number">4</span>] = <span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化接收缓冲区.</span></span><br><span class="line">    <span class="keyword">for</span>(ui32Index = <span class="number">0</span>; ui32Index &lt; NUM_I2C_DATA; ui32Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        pui32DataRx[ui32Index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UARTprintf(<span class="string">&quot;转换方式: 主机 -&gt; 从机</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将I2C数据从主机发送到从机</span></span><br><span class="line">    <span class="keyword">for</span>(ui32Index = <span class="number">0</span>; ui32Index &lt; NUM_I2C_DATA; ui32Index++)</span><br><span class="line">    &#123;</span><br><span class="line">      UARTprintf(<span class="string">&quot;  发送: &#x27;%c&#x27;  . . .  &quot;</span>, pui32DataTx[ui32Index]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将要发送的数据放在数据寄存器中</span></span><br><span class="line">        I2CMasterDataPut(I2C0_BASE, pui32DataTx[ui32Index]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从机回显发送数据到主机</span></span><br><span class="line">        I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_SINGLE_SEND);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待从机接收应答</span></span><br><span class="line">        <span class="keyword">while</span>(!(I2CSlaveStatus(I2C0_BASE) &amp; I2C_SLAVE_ACT_RREQ))</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 从从机寄存器读取数据</span></span><br><span class="line">        pui32DataRx[ui32Index] = I2CSlaveDataGet(I2C0_BASE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待主机接收应答</span></span><br><span class="line">        <span class="keyword">while</span>(I2CMasterBusy(I2C0_BASE))</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        UARTprintf(<span class="string">&quot;接收: &#x27;%c&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>, pui32DataRx[ui32Index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重置接收缓冲区</span></span><br><span class="line">    <span class="keyword">for</span>(ui32Index = <span class="number">0</span>; ui32Index &lt; NUM_I2C_DATA; ui32Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        pui32DataRx[ui32Index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">转换方式: 从机 -&gt; 主机</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//主机从该地址读取数据</span></span><br><span class="line">    I2CMasterSlaveAddrSet(I2C0_BASE, SLAVE_ADDRESS, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化I2C主机模块状态为单端接收</span></span><br><span class="line">    I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待主机请求从机发送数据</span></span><br><span class="line">    <span class="keyword">while</span>(!(I2CSlaveStatus(I2C0_BASE) &amp; I2C_SLAVE_ACT_TREQ))</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(ui32Index = <span class="number">0</span>; ui32Index &lt; NUM_I2C_DATA; ui32Index++)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">      UARTprintf(<span class="string">&quot;  发送: &#x27;%c&#x27;  . . .  &quot;</span>, pui32DataTx[ui32Index]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//将要发送的数据放到从机数据寄存器中</span></span><br><span class="line">        I2CSlaveDataPut(I2C0_BASE, pui32DataTx[ui32Index]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 初始化I2C主机模块状态为单端接收</span></span><br><span class="line">        I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待从机发送完毕</span></span><br><span class="line">        <span class="keyword">while</span>(!(I2CSlaveStatus(I2C0_BASE) &amp; I2C_SLAVE_ACT_TREQ))</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 从主机数据寄存器读取数据</span></span><br><span class="line">        pui32DataRx[ui32Index] = I2CMasterDataGet(I2C0_BASE);</span><br><span class="line">        UARTprintf(<span class="string">&quot;接收: &#x27;%c&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>, pui32DataRx[ui32Index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//显示实验结束</span></span><br><span class="line">    UARTprintf(<span class="string">&quot;</span></span><br><span class="line"><span class="string">传输实验结束.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/01/08/vim%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%B0%8F%E8%AE%B0.18658654/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          vim批量处理小记
        
      </div>
    </a>
  
  
    <a href="/2025/01/03/Markdown%E5%AD%A6%E4%B9%A0.18633990/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Markdown学习</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 shenle
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>