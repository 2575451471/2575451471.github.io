<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>1 | Shenle</title><meta name="robots" content="noindex">

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="article">
<meta property="og:title" content="1">
<meta property="og:url" content="https://github.com/2575451471/2575451471.github.io/2025/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.18632716/index.html">
<meta property="og:site_name" content="Shenle">
<meta property="og:locale">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140748837-1670625892.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140814261-1129941830.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140829152-524126919.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140841192-1671231071.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140856502-260724900.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140907132-1479447052.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140936471-267156122.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140946823-556115847.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141004301-630586186.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141028405-1411185380.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141042690-1032592974.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141130095-1700508162.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141139214-808567108.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141155757-2090768868.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141212621-775870234.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141226289-790240847.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141237552-143389515.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141258128-1015496679.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141319107-810799321.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141412547-729571704.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141426441-2105284687.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141436793-1139720363.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141447432-575499299.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141459190-1171399637.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141513497-570585138.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141525321-1209521997.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141533444-743408046.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141542707-113654271.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141620387-1979244197.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141633379-877175281.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141654601-1352613951.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141709264-1731228494.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141722502-1676144114.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141746270-687183381.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141808195-2102778920.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141822696-722310809.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141832707-1844551597.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141855871-883320052.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141918384-1238156023.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141943978-524809394.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142000724-2117362843.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142010762-1317205879.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142021044-1715699961.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142032321-1750786870.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142042150-827998634.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226235832343-897954371.png">
<meta property="og:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226235916013-733781124.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e160abad667f7afa33d9efb8f4c7e30b.png">
<meta property="og:image" content="https://latex.csdn.net/eq?n%5E%7B2%7D">
<meta property="og:image" content="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B2%7D">
<meta property="og:image" content="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B4%7D">
<meta property="og:image" content="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B8%7D">
<meta property="og:image" content="https://latex.csdn.net/eq?i=%5Cfrac%7Bn%5E%7B2%7D%7D%7B2%5E%7Bt%7D%7D">
<meta property="og:image" content="https://latex.csdn.net/eq?i%20=%201">
<meta property="og:image" content="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E%7B2%7D%7D%7B2%5E%7Bt%7D%7D%20=%201%20%5Cquad%5Cquad%20n%5E2%20=%202%5Et%20%5Cquad%5Cquad%20t%20=%20%5Clog_2n%5E2">
<meta property="og:image" content="https://latex.csdn.net/eq?t%20=%20%5Clog_2n%5E2%20=%202%5Clog_2n">
<meta property="og:image" content="https://latex.csdn.net/eq?T%20=%20O(%5Clog_2n)">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201103101411165.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201103101124969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jlc3VtZVByb2plY3Q=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201103101342353.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210521092357452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jlc3VtZVByb2plY3Q=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20170420/4155837_1492678137490_EDE428B90FC29EFF5CBB176107301433">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://pic4.zhimg.com/v2-4fe6c4db574d58c223ac1c5aba6c283b_b.webp">
<meta property="og:image" content="https://pic2.zhimg.com/v2-9c227393dcc7d55b5e4c5b2d65932b0d_b.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200324222509461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200324222623938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2025-02-14T13:17:00.000Z">
<meta property="article:modified_time" content="2025-02-14T20:21:43.049Z">
<meta property="article:author" content="shenle">
<meta property="article:tag" content="1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140748837-1670625892.png">
  
    <link rel="alternative" href="/atom.xml" title="Shenle" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>

<script src="/js/Counter.js"></script>

  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/header.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">shenle</a></h1>
		</hgroup>

		
			<p class="header-subtitle"></p>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
					        
								<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
					        
								<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=1941325363&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">上课笔记</a> <a href="/tags/%E5%B0%8F%E8%AE%B0/" style="font-size: 15px;">小记</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F32/" style="font-size: 15px;">嵌入式32</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F51/" style="font-size: 10px;">嵌入式51</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8Fti/" style="font-size: 10px;">嵌入式ti</a> <a href="/tags/%E6%99%BA%E8%83%BD%E8%BD%A6%E7%AB%9E%E8%B5%9B/" style="font-size: 10px;">智能车竞赛</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 20px;">编程语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">噜啦啦!</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/header.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/2575451471" title="github">github</a>
			        
						<a class="cnblogs" target="_blank" href="https://www.cnblogs.com/shenleblog" title="cnblogs">cnblogs</a>
			        
						<a class="qq" target="_blank" href="https://img2023.cnblogs.com/blog/3084836/202502/3084836-20250215043636691-2144966981.jpg" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-数据结构.18632716" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.18632716/" class="article-date">
  	<time datetime="2025-02-14T13:17:00.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      1
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/1/" rel="tag">1</a></li></ul>
	</div>

        

        
          
<div class="counter-tag counter">
    <span id="/2025/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.18632716/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="1">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <meta name=referrer content=no-referrer/>
<span id="more"></span>


<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ol>
<li>数值型数据：整数，实数</li>
<li>非数值型数据：文字、图像、图形、声音</li>
</ol>
<p>由数据元素组成</p>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据的基本单位：元素，记录，结点，顶点</p>
<p>是集合的个体</p>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>构成数据元素的不可分割的最小单位</p>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>性质相同的数据元素的集合，数据的一个子集</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据元素相互之间的关系称为结构</p>
<p>数据结构是带结构的数据元素的集合</p>
<p>数据结构包括：</p>
<ul>
<li>数据的逻辑结构（数据元素之间的逻辑关系）</li>
<li>数据的存储结构（数据元素及其关系在计算机内存中的表示-映像）</li>
<li>数据的运算和实现（对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现）</li>
</ul>
<h3 id="数据结构的两个层次"><a href="#数据结构的两个层次" class="headerlink" title="数据结构的两个层次"></a>数据结构的两个层次</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据元素之间的逻辑关系</p>
<p>与数据的存储无关，独立于计算机</p>
<p>是从具体问题抽象出来的数学模型</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>数据元素及其关系在计算机存储器中的结构</p>
<h4 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h4><p>存储结构是逻辑关系的映像与元素本身的映像</p>
<p>逻辑结构是数据皆否的抽象，存储结构是数据结构的实现</p>
<h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><h3 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1.线性结构"></a>1.线性结构</h3><p>线性表，栈，队列，串</p>
<h3 id="1-非线性结构"><a href="#1-非线性结构" class="headerlink" title="1.非线性结构"></a>1.非线性结构</h3><p>树，图</p>
<p>2.集合结构</p>
<p>2.线性结构</p>
<p>2.树形结构</p>
<p>2.图状结构</p>
<h2 id="四种基本的存储结构"><a href="#四种基本的存储结构" class="headerlink" title="四种基本的存储结构"></a>四种基本的存储结构</h2><p>顺序存储结构：连续存储单元存储数据</p>
<p>链式存储结构：任意存储单元存储数据，指针</p>
<p>索引存储结构：建立附加索引表</p>
<p>散列存储结构（哈希）：根据关键字计算出位置</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称</p>
<p>数据类型&#x3D;值的集合+值集合上的一些操作</p>
<p>int,char,float,double等基本数据类型</p>
<p>数组，结构，共用体，枚举等构造数据类型</p>
<p>指针，空类型</p>
<p>typedef自定义数据类型</p>
<p>数据类型约束了常量或变量的取值范围和操作</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140748837-1670625892.png" alt="img"></p>
<h2 id="抽象数据类型（ADT）"><a href="#抽象数据类型（ADT）" class="headerlink" title="抽象数据类型（ADT）"></a>抽象数据类型（ADT）</h2><p>是指一个数据模型以及定义在此数据模型上的一组操作</p>
<p>（不考虑在计算机内部的具体存储结构与运算的具体实现算法）</p>
<h3 id="抽象数据类型的形式定义"><a href="#抽象数据类型的形式定义" class="headerlink" title="抽象数据类型的形式定义"></a>抽象数据类型的形式定义</h3><p>D  S  P(D是数据对象，S是D上的关系集,P是对D的基本操作集)</p>
<p>数据对象，数据关系的定义用伪代码描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">	数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">	基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>

<p>基本操作的定义格式：</p>
<ul>
<li>基本操作名（参数表）为操作提供输入值，引用参数以&amp;打头，除了可以提供输入值外，还将返回操作结果</li>
<li>初始条件：（初始条件描述）描述操作执行之前数据结构和参数应该满足的条件，若不满足则操作失败，并返回相应出错消息，若初始条件是空，则省略</li>
<li>操作结果：（操作结果描述）如果操作正常完成之后，数据结构的变化状况和应该返回的结果</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140814261-1129941830.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140829152-524126919.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140841192-1671231071.png" alt="img"></p>
<p>抽象数据类型可以通过固有的数据类型（如整型，实型，字符型）来表示和实现</p>
<p>注：可以使用类C语言（介于伪码和C语言之间）作为描述工具</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140856502-260724900.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140907132-1479447052.png" alt="img"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对特定问题求解方法和步骤的一种描述，是指令的有限序列</p>
<h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><ul>
<li>自然语言：英语，中文</li>
<li>流程图：传统流程图，NS流程图</li>
<li>伪代码，类语言：C语言</li>
<li>程序代码：</li>
</ul>
<h3 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h3><p>一个问题可以有多种算法</p>
<p>程序是用某种程序设计语言对算法的具体实现</p>
<h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>零个或多个输入</li>
<li>一个或者多个输出</li>
</ul>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
</ul>
<h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><ul>
<li>时间效率</li>
<li>空间效率</li>
</ul>
<h4 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h4><p>算法时间效率可以用依据该算法变只的程序在计算机上执行所消耗的时间来度量</p>
<ul>
<li>事后统计</li>
<li>事前分析：算法运行时间&#x3D;一个简单操作所需的时间*简单操作次数</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140936471-267156122.png" alt="img"></p>
<p>（每条语句的执行次数也叫语句频度）</p>
<p>算法运行时间只考虑语句频度即可</p>
<p>最终只比较数量级（最高项）：算法时间复杂度的渐进表示法</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226140946823-556115847.png" alt="img"></p>
<ul>
<li>最坏时间复杂度</li>
<li>平均时间复杂度</li>
<li>最好时间复杂度（一般考虑最坏和平均）</li>
</ul>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141004301-630586186.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141028405-1411185380.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141042690-1032592974.png" alt="img"></p>
<h4 id="算法空间效率的度量"><a href="#算法空间效率的度量" class="headerlink" title="算法空间效率的度量"></a>算法空间效率的度量</h4><p>空间复杂度：算法所需存储空间的度量</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141130095-1700508162.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141139214-808567108.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141155757-2090768868.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141212621-775870234.png" alt="img"></p>
<h1 id="类C语言操作"><a href="#类C语言操作" class="headerlink" title="类C语言操作"></a>类C语言操作</h1><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141226289-790240847.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141237552-143389515.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141258128-1015496679.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141319107-810799321.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141412547-729571704.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141426441-2105284687.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141436793-1139720363.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141447432-575499299.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141459190-1171399637.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141513497-570585138.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141525321-1209521997.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141533444-743408046.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141542707-113654271.png" alt="img"></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h2><p>线性表是具有相同特性的数据元素的一个有限序列</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141620387-1979244197.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141633379-877175281.png" alt="img"></p>
<h2 id="线性表的案例引入"><a href="#线性表的案例引入" class="headerlink" title="线性表的案例引入"></a>线性表的案例引入</h2><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141654601-1352613951.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141709264-1731228494.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141722502-1676144114.png" alt="img"></p>
<h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><p>（线性表有顺序存储结构和链式存储结构）</p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141746270-687183381.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141808195-2102778920.png" alt="img"><br><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141822696-722310809.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">//线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType elem[LIST_INIT_SIZE];</span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqlList;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141832707-1844551597.png" alt="img"></p>
<p>eg</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000<span class="comment">//多项式可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">//多项式非零项的定义</span></span><br><span class="line">    <span class="type">float</span> p;<span class="comment">//系数</span></span><br><span class="line">    <span class="type">float</span> e;<span class="comment">//指数</span></span><br><span class="line">&#125;Polynomial;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Polynomial *elem;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//多项式中当前项的个数</span></span><br><span class="line">&#125;SqList;<span class="comment">//多项式的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141855871-883320052.png" alt="img"></p>
<h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141918384-1238156023.png" alt="img"></p>
<h4 id="线性表的初始化"><a href="#线性表的初始化" class="headerlink" title="线性表的初始化"></a>线性表的初始化</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226141943978-524809394.png" alt="img"></p>
<h4 id="销毁线性表"><a href="#销毁线性表" class="headerlink" title="销毁线性表"></a>销毁线性表</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142000724-2117362843.png" alt="img"></p>
<h4 id="清空线性表"><a href="#清空线性表" class="headerlink" title="清空线性表"></a>清空线性表</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142010762-1317205879.png" alt="img"></p>
<h4 id="求线性表的长度"><a href="#求线性表的长度" class="headerlink" title="求线性表的长度"></a>求线性表的长度</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142021044-1715699961.png" alt="img"></p>
<h4 id="判断线性表是否为空"><a href="#判断线性表是否为空" class="headerlink" title="判断线性表是否为空"></a>判断线性表是否为空</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142032321-1750786870.png" alt="img"></p>
<h4 id="顺序表的取值"><a href="#顺序表的取值" class="headerlink" title="顺序表的取值"></a>顺序表的取值</h4><p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226142042150-827998634.png" alt="img"></p>
<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkNode*&amp; L)</span>   <span class="comment">//初始化链表线性表</span></span><br><span class="line">&#123;</span><br><span class="line">    L = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//创建头节点，将其next域置为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListR</span><span class="params">(LinkNode*&amp; L, ElemType a[],<span class="type">int</span> n)</span><span class="comment">//链表尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode* s,*r;</span><br><span class="line">    L=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//分配空间,创建头节点</span></span><br><span class="line">    r = L; <span class="comment">//r始终指向尾节点，初始时指向头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        <span class="comment">//循环建立数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//分配空间</span></span><br><span class="line">        s-&gt;data = a[i];    <span class="comment">//创建数据节点s</span></span><br><span class="line">        r-&gt;next = s;       <span class="comment">//将节点s插入到节点r之后</span></span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">//将尾节点的next域置为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListF</span><span class="params">(LinkNode*&amp; L, ElemType a[], <span class="type">int</span> n)</span><span class="comment">//链表头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode* s;</span><br><span class="line">    L = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));      <span class="comment">//分配空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                               <span class="comment">//创建头节点，将其next域设置为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)                   <span class="comment">//循环建立数据节点s</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//分配空间</span></span><br><span class="line">        s-&gt;data = a[i];                           <span class="comment">//创建数据节点s</span></span><br><span class="line">        s-&gt;next = L-&gt;next;                        <span class="comment">//将节点s插入原首节点前，头节点后</span></span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">     </span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkNode *&amp;L)</span>   <span class="comment">//销毁链表形线性表</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *pre=L,*p=L-&gt;next;  <span class="comment">//pre指向节点p的前驱节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)               <span class="comment">//遍历单链表L</span></span><br><span class="line">    &#123;                 </span><br><span class="line">        <span class="built_in">free</span>(p);                <span class="comment">//释放pre节点</span></span><br><span class="line">        pre=p;                  <span class="comment">//pre,p同步后移一个节点</span></span><br><span class="line">        p=pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pre);                 <span class="comment">//循环结束时p为NULL，pre指向尾节点，释放它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(LinkNode *L)</span>  <span class="comment">//判断链表形线性表是否为空表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(LinkNode *L)</span>  <span class="comment">//求链表形线性表的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    LinkNode *p=L;          <span class="comment">//p指向头节点，n置为0（即头节点的序号为0）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n);           <span class="comment">//循环结束，p指向尾节点，其序号n为节点个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(LinkNode *L)</span>  <span class="comment">//输出链表形线性表</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *p=L-&gt;next;    <span class="comment">//p指向首节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)          <span class="comment">//p不为NULL,输出p节点的data域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;         <span class="comment">//p指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(LinkNode *L,<span class="type">int</span> i,ElemType &amp;e)</span>  <span class="comment">//按序号求链表形顺序表中元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LinkNode *p=L;         <span class="comment">//p指向头节点，j置为0（即头节点的序号是0）</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i错误返回假</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;p!=<span class="literal">NULL</span>)    <span class="comment">//查找第i个节点p</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)           <span class="comment">//不存在第i个数据节点，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>                  <span class="comment">//存在第i个数据节点，返回true</span></span><br><span class="line">    &#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(LinkNode *L,ElemType e)</span>  <span class="comment">//按元素查找链表形顺序表中的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    LinkNode *p=L-&gt;next;       <span class="comment">//p指向首节点，i置为1（即首节点的序号是1）</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="comment">//查找data值为e的节点，其序号是i</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)               <span class="comment">//不存在值为e的节点，返回0</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>                      <span class="comment">//存在值为e的节点，返回其逻辑序号i</span></span><br><span class="line">    <span class="keyword">return</span> (i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkNode *&amp; L,<span class="type">int</span> i,ElemType e)</span>   <span class="comment">//在链表形顺序表中第i个位置插入数据元素e</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LinkNode *p=L,*s;  <span class="comment">//p指向头节点，j置为0（即头节点的序号为0）</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//i错误返回false</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>)  <span class="comment">//查找第i-1个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="comment">//未找到第i-1个节点p，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//找到第i-1个节点p，插入新节点并返回true</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">        s-&gt;data=e; <span class="comment">//创建新节点s,将其data域置为e</span></span><br><span class="line">        s-&gt;next=p-&gt;next;  <span class="comment">//将节点s插入到节点p之后</span></span><br><span class="line">        p-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkNode *&amp; L,<span class="type">int</span> i,ElemType &amp; e)</span>  <span class="comment">//在链表形顺序表中删除第i个数据元素，并且把值赋给e</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LinkNode *p=L,*q;  <span class="comment">//p指向头节点，j置为0（即头节点的序号为0）</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//i错误返回false</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>)  <span class="comment">//查找第i-1个节点p</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="comment">//未找到第i-1个节点p，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//找到第i-1个节点p</span></span><br><span class="line">    &#123; </span><br><span class="line">        q=p-&gt;next;  <span class="comment">//q指向第i个节点</span></span><br><span class="line">        <span class="keyword">if</span>(q==<span class="literal">NULL</span>)  <span class="comment">//若不存在第i个节点，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        e=q-&gt;data;</span><br><span class="line">        p-&gt;next=q-&gt;next;  <span class="comment">//从单链表删除q节点</span></span><br><span class="line">        <span class="built_in">free</span>(q);  <span class="comment">//释放q节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//返回true表示成功删除第i个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="应试部分"><a href="#应试部分" class="headerlink" title="应试部分"></a>应试部分</h1><h1 id="数据结构应试笔记"><a href="#数据结构应试笔记" class="headerlink" title="数据结构应试笔记"></a>数据结构应试笔记</h1><p>1.计算机算法必须具备输入、输出和可行性、确定性、有穷性</p>
<p>2.删除后继节点的语句是P-&gt;next&#x3D;p-&gt;next-&gt;next</p>
<p>3.不论是顺序存储结构的栈还是链式存储结构的栈，其入栈和出栈操作的渐进时间复杂度均为O(1).</p>
<h2 id="4-上三角矩阵："><a href="#4-上三角矩阵：" class="headerlink" title="4.上三角矩阵："></a>4.上三角矩阵：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] a[<span class="number">0</span>][<span class="number">1</span>] a[<span class="number">0</span>][<span class="number">2</span>] a[<span class="number">0</span>][<span class="number">3</span>] a[<span class="number">0</span>][<span class="number">4</span>] a[<span class="number">0</span>][<span class="number">5</span>]</span><br><span class="line">   c    a[<span class="number">1</span>][<span class="number">1</span>] a[<span class="number">1</span>][<span class="number">2</span>] a[<span class="number">1</span>][<span class="number">3</span>] a[<span class="number">1</span>][<span class="number">4</span>] a[<span class="number">1</span>][<span class="number">5</span>]</span><br><span class="line">   c       c    a[<span class="number">2</span>][<span class="number">2</span>] a[<span class="number">2</span>][<span class="number">3</span>] a[<span class="number">2</span>][<span class="number">4</span>] a[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line">   c       c       c    a[<span class="number">3</span>][<span class="number">3</span>] a[<span class="number">3</span>][<span class="number">4</span>] a[<span class="number">3</span>][<span class="number">5</span>]</span><br><span class="line">   c       c       c       c    a[<span class="number">4</span>][<span class="number">4</span>] a[<span class="number">4</span>][<span class="number">5</span>]</span><br><span class="line">   c       c       c       c       c    a[<span class="number">5</span>][<span class="number">5</span>]</span><br></pre></td></tr></table></figure>




<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226235832343-897954371.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3084836/202412/3084836-20241226235916013-733781124.png" alt="img"></p>
<p>5.折半查找&#x3D;二分查找</p>
<h2 id="6-计算时间复杂度"><a href="#6-计算时间复杂度" class="headerlink" title="6.计算时间复杂度"></a>6.计算时间复杂度</h2><p> <img src="https://img-blog.csdnimg.cn/img_convert/e160abad667f7afa33d9efb8f4c7e30b.png" alt="img"> </p>
<p> <strong>解题步骤</strong></p>
<ol>
<li>列出循环趟数t及每轮循环i的变化值</li>
<li>找到t与i的关系</li>
<li>确定循环停止条件</li>
<li>联立两式解方程</li>
<li>写结果</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = n*n;</span><br><span class="line">whlie(i != <span class="number">1</span>)</span><br><span class="line">    i = i/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>第一步：列出循环趟数t及每轮循环i的变化值：</p>
<table>
<thead>
<tr>
<th>t</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td><img src="https://latex.csdn.net/eq?n%5E%7B2%7D" alt="n^{2}"></td>
<td><img src="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B2%7D" alt="rac{n^2}{2}"></td>
<td><img src="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B4%7D" alt="rac{n^2}{4}"></td>
<td><img src="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E2%7D%7B8%7D" alt="rac{n^2}{8}"></td>
</tr>
</tbody></table>
<p>第二步：找到t与i的关系：</p>
<p> <img src="https://latex.csdn.net/eq?i=%5Cfrac%7Bn%5E%7B2%7D%7D%7B2%5E%7Bt%7D%7D" alt="i&#x3D;rac{n^{2}}{2^{t}}"></p>
<p>第三步：确定循环停止条件：</p>
<p><img src="https://latex.csdn.net/eq?i%20=%201" alt="i &#x3D; 1"></p>
<p>第四步：联立第二步第三步两式解方程：</p>
<p><img src="https://latex.csdn.net/eq?%5Cfrac%7Bn%5E%7B2%7D%7D%7B2%5E%7Bt%7D%7D%20=%201%20%5Cquad%5Cquad%20n%5E2%20=%202%5Et%20%5Cquad%5Cquad%20t%20=%20%5Clog_2n%5E2" alt="rac{n^{2}}{2^{t}} &#x3D; 1 \quad\quad n^2 &#x3D; 2^t \quad\quad t &#x3D; \log_2n^2"></p>
<p><img src="https://latex.csdn.net/eq?t%20=%20%5Clog_2n%5E2%20=%202%5Clog_2n" alt="t &#x3D; \log_2n^2 &#x3D; 2\log_2n"></p>
<p>所以得到时间复杂度为：</p>
<p><img src="https://latex.csdn.net/eq?T%20=%20O(%5Clog_2n)" alt="T &#x3D; O(\log_2n)"></p>
<h2 id="7-队列的入队操作："><a href="#7-队列的入队操作：" class="headerlink" title="7.队列的入队操作："></a>7.队列的入队操作：</h2><p>![1699444178149](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699444178149.png)</p>
<p>![1699444327774](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699444327774.png)</p>
<p>![1699964949270](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699964949270.png)</p>
<p>![1699965001693](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699965001693.png)</p>
<p>![1699965071971](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699965071971.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType data[Maxsize];</span><br><span class="line">    <span class="type">int</span> front,rear;  <span class="comment">//队首和队尾指针</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span> <span class="params">(Queue*Q,DataType x)</span></span><br><span class="line">&#123;  <span class="comment">//如果队列不满，则元素x入队列，并返回1；否则返回0</span></span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%Maxsize==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//rear+1=front，队列满了</span></span><br><span class="line">    Q-&gt;data[(Q-&gt;rear+<span class="number">1</span>)%Maxsize]=x;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%Maxsize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.设计直接插入算法，使链表递增</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assending</span><span class="params">(Lnode *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	Lnode *p,*q,*r,*s;  <span class="comment">//p用来前面一段已经排好的表做遍历指针，s用来放在p前面好使得ps间插入节点。q用来对后面一段的最后节点做保留和往后延申，r用来指向每次用来处理的节点。</span></span><br><span class="line">    p=head-&gt;next;<span class="keyword">if</span>(p=<span class="literal">NULL</span>)<span class="keyword">return</span>;<span class="comment">//空链表情形</span></span><br><span class="line">    q=p-&gt;next;p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//分成前后两段</span></span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        r=q;q=q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;key&lt;=p-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=p;head-&gt;next=r;p=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;r-&gt;key&gt;=p-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                s=p;p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r-&gt;next=p;s-&gt;next=r;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.快速排序最坏时间复杂度<strong>O(n^2)</strong></p>
<p>10.线性表L在**（需不断对L进行删除插入）**情况下适合用链式结构实现</p>
<p>11.设指针变量top指向当前链式栈的栈顶，则删除栈顶元素需要的操作是**（top&#x3D;top-&gt;next）**</p>
<p>12.循环队列执行出队操作后，头指针front+1—》front&#x3D;(front+1)%MaxSize;</p>
<p>13.指针变量p指向单链表中节点A，则删除节点A的语句序列是：q&#x3D;p-&gt;next;p-&gt;data&#x3D;q-&gt;data;<strong>p-&gt;next&#x3D;q-&gt;next</strong>;delete q;&#x2F;&#x2F;将P节点复制成q节点，然后删除q节点，这样就不用知道p的前驱节点就能删除“p节点”了</p>
<p>14 .复制子串算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">substring</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> start,<span class="type">int</span> count,<span class="type">char</span> t[])</span></span><br><span class="line">&#123;  <span class="comment">//s为主串指针，start为复制子串开始位置，count为复制子串长度，t为复制子串</span></span><br><span class="line">    <span class="type">long</span> i,j,length;</span><br><span class="line">    length=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span>||start+count&gt;=length) <span class="built_in">printf</span>(<span class="string">&quot;复制的位置不对&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=start,j=<span class="number">0</span>;i&lt;count;i++,j++) t[j]=s[i];</span><br><span class="line">        t[j]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15 .查找链表中倒数第k个位置上的节点–&gt;先计算出长度，计算出长度-k</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(头节点||首节点==空)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p=首节点;</span><br><span class="line"><span class="keyword">while</span>(p不是空节点)</span><br><span class="line">&#123;</span><br><span class="line">    长度++;</span><br><span class="line">    p节点后移;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>（长度小于k）<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p=首节点;</span><br><span class="line"><span class="keyword">for</span>（长度-k次）&#123;p节点后移;&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>16 .线性表采用链式存储时，节点的存储地址<strong>连续与否均可</strong></p>
<p>17 .某算法的时间复杂度为O(2^n)，<strong>表明该算法执行时间与2^n成正比</strong></p>
<p>18 .串的长度是之<strong>串中所含字符的个数</strong></p>
<p>19 .顺序查找不论是在顺序线性表中还是链式线性表中都是O(n);</p>
<p>​      不论是顺序存储结构的栈还是链式存储结构的栈，其入栈和出栈操作的时间复  杂度均为 <strong>O(1)</strong>。 </p>
<p>20 .利用直接插入排序法建立一个有序线性表的平均时间复杂度是<strong>O(n^2)</strong></p>
<p>21.带表头附加节点的单链表判断为空：L-&gt;next&#x3D;NULL;循环链表判断为空：L-&gt;next&#x3D;L;</p>
<h2 id="22-入栈和出栈"><a href="#22-入栈和出栈" class="headerlink" title="22.入栈和出栈"></a>22.入栈和出栈</h2><p>![1700540591482](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1700540591482.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> 入栈(栈s,元素e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(栈顶指针-栈底指针&gt;=栈最大容量)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈满</span></span><br><span class="line">	使得栈顶指针指向e；</span><br><span class="line">	栈顶指针地址+<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> 出栈（栈s,元素e）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>（栈顶指针==栈底指针）<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空</span></span><br><span class="line">	栈顶指针地址--；</span><br><span class="line">	使得栈顶指针指向e；</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>23 .在线性表中，<strong>除了第一个和最后一个元素，其余每一个元素至少有一个且仅有一个直接前驱和直接后继</strong></p>
<p>24 .三元组表中的每个节点对应于稀疏矩阵的一个非零元素，它包含有三个数据项，分别是<strong>行下标，列下标，元素值</strong></p>
<p>25 .入栈元素n个，出栈序列有![1699451185913](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699451185913.png)种。</p>
<p>26 .如果排序改变了关键字相同的记录之间的相对次序，则该排序方法是<strong>不稳定的</strong></p>
<p>27 .递归方法使得队列倒序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType e;</span><br><span class="line">	<span class="keyword">if</span>(!(QueueEmpty(Q)))  <span class="comment">//递归条件为队列非空</span></span><br><span class="line">	&#123;</span><br><span class="line">		DeQueue(Q，e);  <span class="comment">//删除对头元素，e存入</span></span><br><span class="line">		f2(Q);</span><br><span class="line">		EnQueue(Q,e); <span class="comment">//插入元素e作为队尾</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28 .线性表是具有n个元素的一个有限序列（n&gt;&#x3D;0）</p>
<p>29 算法分析的两个主要方面是<strong>空间复杂度和时间复杂度</strong></p>
<p>30 .与线性表相比，串的插入和删除操作的特点是<strong>通常以串为整体作为操作对象</strong></p>
<p>31.广义表的长度定义为最外层包含元素的个数，深度定义为所含括弧的重数，其中原子的深度为0，空表的深度为1</p>
<p>32 .将链表的顺序前后颠倒:将链表分成两段，使用头插法重新链接链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(Node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node *p,*q=<span class="literal">NULL</span>;</span><br><span class="line">	p=head-&gt;next;head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		p-&gt;next=head-&gt;next;</span><br><span class="line">		head-&gt;next=p;</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>33.删除循环链表中数据域大于c的节点并让被删除的节点构成新的循环链表，返回新的循环链表的头节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">f3</span><span class="params">(LinkList L,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	定义新头节点Lc，用于前后遍历的前驱节点、后继节点;</span><br><span class="line">	前驱节点=头节点L；</span><br><span class="line">	后继节点=前驱节点的后继；</span><br><span class="line">	头节点Lc分配空间；</span><br><span class="line">	头节点Lc指向头节点本身，构成循环；</span><br><span class="line">	<span class="keyword">while</span>(后继节点不为空)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>（后继节点的数据域大于C）</span><br><span class="line">        &#123;</span><br><span class="line">        	将前驱指向后继的后继，除去后继节点；</span><br><span class="line">        	将被除去的后继插入到Lc和Lc-&gt;next中间；</span><br><span class="line">        	后继重新指向前驱的后继</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>(后继节点的数据域小于等于c)</span><br><span class="line">        &#123;</span><br><span class="line">        	前驱节点和后继节点后移</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> 头节点Lc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>34.双向链表直接插入排序算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	node *p1,*p2,*p3;</span><br><span class="line">	p1=head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p1)</span><br><span class="line">	&#123;</span><br><span class="line">		p2=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(p2-&gt;key&lt;=p1-&gt;key&amp;&amp;p2!=p1)p2=p2-&gt;next;</span><br><span class="line">		<span class="comment">//在已经排序好了的链表中找到首个key值大于p1-&gt;key的节点</span></span><br><span class="line">		<span class="keyword">if</span>(p2==p1)p1=p1-&gt;next<span class="comment">//p1最大，后移</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//此时p2比p1大</span></span><br><span class="line">		&#123;</span><br><span class="line">			p3=p1-&gt;next; <span class="comment">//p3保留p1后继节点</span></span><br><span class="line">			p3-&gt;prior=p1-&gt;prior;<span class="comment">//p3前驱链接</span></span><br><span class="line">			p1-&gt;prior-&gt;next=p3;<span class="comment">//p3前驱链接</span></span><br><span class="line">			p2-&gt;prior-&gt;next=p1;p1-&gt;prior=p2-&gt;prior;</span><br><span class="line">			<span class="comment">//p1前驱链接</span></span><br><span class="line">			p1-&gt;next=p2;p2-&gt;prior=p1;<span class="comment">//p1后继链接</span></span><br><span class="line">			p1=p3; <span class="comment">//p1重新代替保留节点的p3 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>35 .链式存储的存储结构方式所占存储空间<strong>分两部分，一部分存放节点值，另一部分存放表示节点间关系的指针</strong></p>
<p>36 .不论是顺序存储结构的栈还是链式存储结构的栈（长度为n），其入栈还是出栈的时间复杂度都是<strong>O(1)</strong>.</p>
<p>37 .空串的长度等于<strong>0</strong>.</p>
<p>38 .计算矩阵乘法C&#x3D;AB ,渐进复杂度O（n^3）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i][j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[i][j]=C[i][j]+A[i][k]*B[k][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-栈的基本操作"><a href="#39-栈的基本操作" class="headerlink" title="39.栈的基本操作"></a>39.栈的基本操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType *base; <span class="comment">//栈底指针</span></span><br><span class="line">	SElemType *top; <span class="comment">//栈顶指针 --&gt;指向栈顶元素的下一个位置</span></span><br><span class="line">	<span class="type">int</span> stacksize; <span class="comment">//栈的当前最大容量</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//构造一个容量为MaxSize的空栈</span></span><br><span class="line">	S.base=(SElemType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">	<span class="comment">//分配空间</span></span><br><span class="line">	<span class="keyword">if</span>(S.base!=<span class="literal">NULL</span>)<span class="keyword">return</span> error;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=MaxSize;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line">	<span class="keyword">if</span>（S.top-S.base&gt;=S.stacksize)<span class="keyword">return</span> error;<span class="comment">//栈满</span></span><br><span class="line">	*S.top=e; <span class="comment">//栈顶指针指向栈顶元素的下一个位置，所以先赋值</span></span><br><span class="line">	S.top++;<span class="comment">//栈顶指针指向新的栈顶元素的下一个位置</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//删除栈顶元素，用e返回其值</span></span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> error;<span class="comment">//栈空</span></span><br><span class="line">	S.top--;</span><br><span class="line">	e=*S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40 .交换p所指向的节点和它的直接前驱节点的顺序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span> <span class="params">(node*p)</span></span><br><span class="line">&#123;</span><br><span class="line">	node *q;</span><br><span class="line">	q=p-&gt;prior</span><br><span class="line">	</span><br><span class="line">	p-&gt;prior=q-&gt;prior;</span><br><span class="line">	q-&gt;prior-&gt;next=p;</span><br><span class="line">	</span><br><span class="line">	q-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next-&gt;prior=q;</span><br><span class="line">	</span><br><span class="line">	q-&gt;prior=p;</span><br><span class="line">	p-&gt;next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>41 .在一个长度为n的顺序线性表中查找值为x的元素，查找成功时的平均长度为**（n+1）&#x2F;2**</p>
<p>42.对于一个算法的评价，包括健壮性、可读性、正确性、时空复杂度的评价，不包括<strong>并行性</strong>的评价</p>
<p>43 .算法分析的目的是<strong>分析算法的效率以求改进</strong></p>
<p>44 .设计一个判别表达式中左右括号是否匹配的算法，采用<strong>栈</strong>数据结构最佳</p>
<p>45 .设输入序列1、2、3……、n经过栈作用后，输出序列中的第一个元素是n，则输出序列的第i个元素是<strong>n+1-i</strong> </p>
<p>46 .栈和队列的共同特点是<strong>只允许在端点处插入和删除元素</strong></p>
<p>47 .队列、栈、线性表是线性结构的，二叉树不是</p>
<p>48 。线性表采用顺序结构存储时必须占用一片连续的存储空间，不便于插入和删除操作。线性表采用链式结构存储时不必占用一片连续的存储空间，便于插入和删除操作。</p>
<p>49 . 数据的物理结构包括<strong>顺序存储和链式存储</strong>，数据的物理结构又叫存储结构。 </p>
<p>50 .队列结构的元素个数是可变的</p>
<p>51 .四种基本逻辑结构（集合、线性结构、树形结构、图状结构）中<strong>集合</strong>的数据元素之间关系最弱</p>
<p>52 .一个数据结点存放一个<strong>数据元素</strong></p>
<p>53 .在线性表的顺序存储中，逻辑上相邻的数据元素在物理位置上也是相邻的</p>
<p>54 .在循环单链表的一个结点中有（1）个指针域</p>
<p>55 .在进栈操作前要判断（栈满否）， 在出栈操作前要判断（栈空否）</p>
<p>数据结构的研究的内容包括：数据的逻辑结构、数据的（类型）、数据的 运算</p>
<p>56 .算法是对解题方法和步骤的描述（√）</p>
<p>57 .对数据的任何运算都不能改变数据原有的结构类型（×）</p>
<p>58 .从循环单链表的任意节点出发，可以找到表中所有结点（√）</p>
<p>59 .栈和队列的存储方式既可以是顺序方式也可以是链式（√）</p>
<p>60 .数据结构中，与所使用的计算机无关的是数据的（逻辑）结构</p>
<p>61 .与线性表的链式存储相符的特性是（插入和删除操作灵活）</p>
<p>62 .栈和队列都是（限制存取点的线性结构）</p>
<p>63 .用链接方式存储的队列，在进行插入运算时（头尾指针都可能要修改）</p>
<p>64 .通常从四个方面评价算法的质量：（正确性、可读性、高效性、健壮性）</p>
<h2 id="65-中缀表达式和后缀表达式"><a href="#65-中缀表达式和后缀表达式" class="headerlink" title="65 .中缀表达式和后缀表达式"></a>65 .中缀表达式和后缀表达式</h2><p>中缀表达式：就是日常的算术表达式</p>
<p>后缀表达式：将运算符放到数字后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将中缀表达式转化成后缀表达式：</span><br><span class="line"><span class="number">1.</span>按运算符优先级对所有运算符和运算数加括号                           <span class="number">2.</span>将运算符移到对应的括号后                                     </span><br><span class="line"><span class="number">3.</span>去掉括号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![1699963731144](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699963731144.png)</p>
<p>66 .入栈：栈顶指针是先加1再放入元素数据</p>
<p>​      出栈：先复制元素数据再栈顶指针减1</p>
<p> 67 .设一维数组中有n个数组元素，则读取第i个数组元素的平均时间复杂度为<strong>O（1）</strong>。</p>
<p> 68 . 设用链表作为栈的存储结构则退栈操作**（ 必须判断栈是否为空 ）**。</p>
<p>（ 链表实现的栈的物理地址可以不连续，所以一般不需要判断栈满，但是顺序栈和链栈都要进行判空操作。 ） </p>
<p>69 .设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储**（M-1）**个队列元素；当前实际存储(（R-F+M）%M)个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。 </p>
<p>( 因为如果放置M个元素，首尾指针指向同一位置，与空队列无法区别，所以循环队列中认为当尾指针的后一个指针为首指针时，判定队列为满队列，即只能保存M-1个元素。 )</p>
<h2 id="70-广义表的存储结构和代码："><a href="#70-广义表的存储结构和代码：" class="headerlink" title="70 .广义表的存储结构和代码："></a>70 .广义表的存储结构和代码：</h2><p>​        链式(头尾链表)存储结构：使用原子节点(长度为2)存储值 </p>
<p> <img src="https://img-blog.csdnimg.cn/20201103101411165.png#pic_center" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20201103101124969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jlc3VtZVByb2plY3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20201103101342353.png#pic_center" alt="在这里插入图片描述"> </p>
<p>扩展的线性表存储结构</p>
<p> <img src="https://img-blog.csdnimg.cn/20210521092357452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jlc3VtZVByb2plY3Q=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p>
<p>举例：</p>
<p> 画出广义表 LS&#x3D;(( ) , (e) , (a , (b , c , d ))) 的头尾链表存储结构。 </p>
<p> <img src="https://uploadfiles.nowcoder.com/images/20170420/4155837_1492678137490_EDE428B90FC29EFF5CBB176107301433" alt="img"> </p>
<p>广义表的结点类型GLnode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> tag;  <span class="comment">//结点类型标识</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ElemType data;  <span class="comment">//存放原子值（tag=0）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lnode</span> *<span class="title">sublist</span>;</span>  <span class="comment">//指针指向子表的第一个元素</span></span><br><span class="line">                                <span class="comment">//对应结点的地址（tag=1）</span></span><br><span class="line">    &#125;val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lnode</span> *<span class="title">link</span>;</span>  <span class="comment">//指向下一个元素（兄弟结点）</span></span><br><span class="line">&#125;GLNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>求解广义表递归算法一般形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1（考虑兄弟）头结点无兄弟，其各个子表的处理和整个广义表的处理相似</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(GLNode *g)</span>  <span class="comment">//g为广义表结点指针</span></span><br><span class="line">&#123;</span><br><span class="line">    GLNode &amp;g1=g-&gt;val.sublist;  <span class="comment">//g1指向第一个元素</span></span><br><span class="line">    <span class="comment">//每个元素对应一个小问题：一个递归出口+一个递归体</span></span><br><span class="line">    <span class="keyword">while</span>(g1!=<span class="literal">NULL</span>)  <span class="comment">//元素未处理完则循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g1-&gt;tag==<span class="number">1</span>)  <span class="comment">//为子表时</span></span><br><span class="line">            fun(g1); <span class="comment">//递归处理</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            原子处理语句；  <span class="comment">//实现原子操作</span></span><br><span class="line">        g1=g1-&gt;link;  <span class="comment">//处理兄弟（下一个元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2（考虑第一个儿子和右侧第一个兄弟）头结点看作有个“空兄弟”，元素、兄弟的处理都与整个广义表的处理是相似的。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(GLNode *g)</span>  <span class="comment">//g为广义表结点指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(g!=<span class="literal">NULL</span>)  <span class="comment">//递归时可能g为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g-&gt;tag==<span class="number">1</span>)              <span class="comment">//有儿子：为子表时</span></span><br><span class="line">            fun2(g-&gt;val.sublist);  <span class="comment">//有儿子：递归处理其元素</span></span><br><span class="line">        <span class="keyword">else</span>                       <span class="comment">//无儿子：实现原子操作</span></span><br><span class="line">            原子处理语句；           <span class="comment">//无儿子：实现原子操作</span></span><br><span class="line">        fun2(g-&gt;link);             <span class="comment">//递归处理其兄弟</span></span><br><span class="line">                                   <span class="comment">//头结点为空时”空兄弟“</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>求广义表的长度</p>
<p>![1701267537057](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267537057.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在广义表中，同一层次的每个结点是通过link域链接起来的，所以可把他看作时由link域链接起来的单链表，这样求广义表的长度就是求单链表的长度。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GLLength</span><span class="params">(GLNode *g)</span>  <span class="comment">//求广义表的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;  <span class="comment">//累计元素个数，初始值为0</span></span><br><span class="line">    GLNode *g1;</span><br><span class="line">    g1=g-&gt;val.sublist;  <span class="comment">//g1指向广义表的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(g1!=<span class="literal">NULL</span>)  <span class="comment">//扫描所有元素结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        n++;  <span class="comment">//扫描所有元素结点</span></span><br><span class="line">        g1=g1-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;  <span class="comment">//返回元素个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>求广义表深度的递归模型</p>
<p>![1701267548698](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267548698.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广义表深度的递归定义是它等于所有子表中表的最大深度+1，</span></span><br><span class="line">f(g)=<span class="number">0</span>  <span class="comment">//g为原子</span></span><br><span class="line">f(g)=<span class="number">1</span>  <span class="comment">//g为空表</span></span><br><span class="line">f(g)=MAX&#123;f(subg)+<span class="number">1</span>&#125;  <span class="comment">//其他情况</span></span><br><span class="line"><span class="type">int</span> GLDepth(GLNode *g)  <span class="comment">//求广义表g的深度</span></span><br><span class="line">&#123;</span><br><span class="line">    GLNode *g1; <span class="type">int</span> maxd=<span class="number">0</span>,dep;</span><br><span class="line">    <span class="keyword">if</span>(g-&gt;tag==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//为原子时返回0</span></span><br><span class="line">    g1=g-&gt;val.sublist;  <span class="comment">//g1指向第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(g1==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//为空表时返回1</span></span><br><span class="line">    <span class="keyword">while</span>(g1!=<span class="literal">NULL</span>)  <span class="comment">//遍历表中的每一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出广义表</p>
<p>![1701269179436](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701269179436.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispGL</span><span class="params">(GLNode *g)</span></span><br><span class="line">&#123;  <span class="keyword">if</span> (g!=<span class="literal">NULL</span>)    <span class="comment">//第一次不为空，递归时可能为空</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tag==<span class="number">0</span>)	<span class="comment">//原子时,第1次不可能是原子</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, g-&gt;val.data);</span><br><span class="line">      <span class="keyword">else</span>				<span class="comment">//子表时</span></span><br><span class="line">      &#123;  <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);			<span class="comment">//输出&#x27;(&#x27;</span></span><br><span class="line">         <span class="keyword">if</span> (g-&gt;val.sublist==<span class="literal">NULL</span>)	<span class="comment">//空表</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">         <span class="keyword">else</span>				<span class="comment">//非空表</span></span><br><span class="line">            DispGL(g-&gt;val.sublist);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);			<span class="comment">//输出&#x27;)&#x27;</span></span><br><span class="line">      &#125;					<span class="comment">//孩子问题</span></span><br><span class="line">      <span class="keyword">if</span> (g-&gt;link!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;  <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">         DispGL(g-&gt;link);		<span class="comment">//兄弟问题</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>求广义表的原子个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用解法1的方法（n个小问题）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Count1</span><span class="params">(GLNode *g)</span>		<span class="comment">//求广义表g的原子个数</span></span><br><span class="line">&#123;  <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">   GLNode *g1=g-&gt;val.sublist;</span><br><span class="line">   <span class="keyword">while</span> (g1!=<span class="literal">NULL</span>)		<span class="comment">//对每个元素进行循环处理</span></span><br><span class="line">   &#123;  <span class="keyword">if</span> (g1-&gt;tag==<span class="number">0</span>)		<span class="comment">//为原子时</span></span><br><span class="line">	   n++;			<span class="comment">//原子个数增1</span></span><br><span class="line">      <span class="keyword">else</span>			<span class="comment">//为子表时</span></span><br><span class="line">	   n+=Count1(g1);	<span class="comment">//累加元素的原子个数</span></span><br><span class="line">      g1=g1-&gt;link;		<span class="comment">//累加兄弟的原子个数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> n;			<span class="comment">//返回总原子个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用解法2的方法（2个小问题）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Count2</span><span class="params">(GLNode *g)</span>			<span class="comment">//求广义表g的原子个数</span></span><br><span class="line">&#123;  <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (g!=<span class="literal">NULL</span>)			<span class="comment">//对每个元素进行循环处理</span></span><br><span class="line">   &#123;  <span class="keyword">if</span> (g-&gt;tag==<span class="number">0</span>)			<span class="comment">//无孩子：为原子</span></span><br><span class="line">	 n++;				<span class="comment">//原子个数增1</span></span><br><span class="line">      <span class="keyword">else</span>				<span class="comment">//有孩子：为子表</span></span><br><span class="line">	 n+=Count2(g-&gt;val.sublist);	<span class="comment">//累加元素的原子个数</span></span><br><span class="line">      n+=Count2(g-&gt;link);		<span class="comment">//兄弟问题</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> n;				<span class="comment">//返回总原子个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="71-数据的最小单位是-（数据项）"><a href="#71-数据的最小单位是-（数据项）" class="headerlink" title="71 .数据的最小单位是**（数据项）** "></a>71 .数据的最小单位是**（数据项）** <img src="https://img-blog.csdnimg.cn/20190618173532304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMxNjU3ODg5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p> 72 .substr函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">str=substr(x,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">put str=;</span><br><span class="line">run;</span><br><span class="line">在<span class="built_in">log</span>中输出结果为: str=<span class="number">123</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="73-共享栈"><a href="#73-共享栈" class="headerlink" title="73 .共享栈"></a>73 .共享栈</h2><p>![1699968756906](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1699968756906.png)</p>
<p>74 .设指针变量top指向当前链式栈的栈顶，则删除栈顶元素的操作序列为**（top&#x3D;top-&gt;next）**</p>
<p>(如果是顺序栈，则为top&#x3D;top-1)</p>
<p>75 . 无论是入队操作还是入栈操作，在顺序存储结构上都需要考虑“溢出”情况。说法是否正确**(√)**</p>
<p>76 .线性表中的所有元素都有一个前驱节点和后继节点**（×）**</p>
<p> 77 .字符串的长度是指**（ 字符串所含的字符个数，但不包括最后的’0’ ）**</p>
<p>78 .设计一个有序单链表的时间复杂度为<strong>O(n^2)</strong></p>
<p>79 .二维数组和多维数组均不是线性结构</p>
<p>80 .顺序查找指的是在顺序存储结构上进行查找**（×）**</p>
<p>（顺序查找指的是从第一个元素开始查找一直到最后一个元素为止，所以它在链表上也可以进行）</p>
<p>81 .某链表中最常用的操作是在链表的尾部插入或者删除元素，则选用**（双向循环链表）**的存储方式最节省时间</p>
<p>82 . 数据结构在逻辑上划分为<strong>树、图、线性结构</strong> </p>
<p>83 .数据结构是一门研究程序设计中数据的<strong>元素</strong>以及他们之间<strong>结构</strong>和运算的学科</p>
<p>86 .数据的逻辑结构分为<strong>线性结构和非线性结构</strong></p>
<p>87 ，数据的逻辑结构是指<strong>数据元素之间的逻辑关系</strong></p>
<p> 88 . 在链式存储结构中，通常一个存储节点用于存储一个（ B ）<br>A. 数据项 B. 数据元素 C. 数据结构 D. 数据类型 </p>
<p>89 .在数据结构中，与所使用的计算机无关的是（ C ）<br>A. 数据的存储结构 B. 数据结构 C. 数据的逻辑结构 D. 数据元素之间的关系 </p>
<p>90 .数据运算的执行（ C ）<br>A. 效率与采用何种存储结构有关 B. 是根据存储结构来定义的<br>C. 有算术运算和关系运算两大类 D. 必须用程序设计语言来描述</p>
<p> 91 ．某算法的时间复杂度为O(n2)，表明该算法的（ c）<br>A. 问题的规模是n2 B. 执行时间等于n2<br>C. 执行时间与n2成正相关 D. 问题规模与n2成正比 </p>
<p> 92 . 算法分析的主要任务之一是分析（ C ）<br>A. 算法是否具有较好的可读性 B. 算法中是否存在语法错误<br>C. 算法的功能是否符合设计要求 D. 算法的执行时间和问题规模之间的关系</p>
<p> 93 .算法分析的目的是：（ C ）<br>A. 找出数据结构的合理性 B. 研究算法中输入和输出关系<br>C. 分析算法的效率以求改进 D. 分析算法的易读性和健壮性</p>
<p>94 . 数据结构在计算机内存中的（表示）是指（ A ）。<br>A.数据的逻辑结构<br>B.数据结构<br><strong>C.数据的存储结构</strong><br>D.数据元素之间的关系 </p>
<p>95 . 组成数据的基本单位是（ B ）。<br>A.数据类型<br><strong>B.数据元素</strong><br>C.数据变量<br>D.数据项 </p>
<p>96 .数据的逻辑结构是（D ）。<br>A.数据的存储形式<br>B.数据的表示形式<br>C.数据的实现形式<br><strong>D.数据的组织形式</strong> </p>
<h2 id="97-算法的5个特性："><a href="#97-算法的5个特性：" class="headerlink" title="97 . 算法的5个特性："></a>97 . 算法的5个特性：</h2><p> 输入、输出、有穷性、确定性、可行性  </p>
<p> 98 .数据结构包含三个方面的内容，<br>分别是<strong>逻辑结构、存储结构（物理结构）、数据的运算</strong>。 </p>
<p>99 .算法的时间复杂度与问题规模有关</p>
<p>100 .算法的空间复杂度是指（ 执行这个算法所需要的内存空间 ）</p>
<p>101 .数据的逻辑结构是指数据元素之间的逻辑关系n </p>
<p>102 . 顺序存储方法： 该方法把逻辑上<strong>相邻的结点</strong>存储在物理位置上<strong>相邻的存储单元</strong>里，结点间的逻辑关系由<strong>存储单元的邻接关系</strong>来体现。、</p>
<p>​        链接存储方法： 该方法不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系由<strong>附加的指针字段表示</strong>。 </p>
<p>103 . 算法的执行时间是**时间复杂度的函数  ** </p>
<p>104 .在算法描述中，在算法中对引用型参数的修改就是对相应<strong>实参</strong>的修改</p>
<p>105 . 数据对象：<strong>具有相同性质的</strong>数据元素的集合，是数据的一个子集。而不是一组数据元素的集合</p>
<p> 106 .每种数据结构都具备三个基本运算:插入、删除和查找,这种说法( )。<br>A、 正确<br>B、 不正确<br>正确答案： B</p>
<p>解析：比如二维数组它不具有插入和删除的功能</p>
<p>106 .数据对象是由有限个类型相同的数据元素组成的（√）</p>
<p>107 . 逻辑结构相同的数据，可以采用多种不同的存储方法。√ </p>
<p>108 . 逻辑结构不相同的数据应该采用不同的存储结构。( ×) </p>
<p>109 . 数据的逻辑结构是指数据的各数据项之间的逻辑关系。( × )</p>
<p>110 .什么是存储实现？什么是运算实现？</p>
<p>存储实现：逻辑结构在计算机内的存储方式，包括顺序存储和链式存储等。</p>
<p>运算实现：指如何在数据结构上实现各种基本操作，例如插入、删除、查找等</p>
<p>111 .若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用**（A．顺序表 ）** 存储方式最节省时间。</p>
<p>112 .某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用（<strong>仅有尾指针的单循环链表</strong>  ）存 储方式最节省运算时间。</p>
<p>113  .若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点。则采用（ <strong>.带头结点的双循环链表</strong>）存储 方式最节省运算时间。</p>
<p>114．设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用( <strong>.带头结点的双循环链表</strong> )最节省时间。 </p>
<p>115  静态链表中指针表示的是（下一元素地址  ）.</p>
<p>116 .链表不具有的特点是（<strong>可随机访问任一元素</strong>）</p>
<p>117 . 链表中的头结点仅起到标识的作用。( ×)</p>
<p>头结点并不仅起标识作用，并使操作统一。另外，结点数据域可写入链表长度，或作监视哨。</p>
<p>118 .集合与线性表的区别在于是否按关键字排序。( ×)</p>
<p>119 . 所谓静态链表就是一直不发生变化的链表。( ×)</p>
<p>120 . 循环链表不是线性表. ( ×)</p>
<p>121 .．为了很方便的插入和删除数据，可以使用双向链表存放数据。( √) </p>
<p>122 ．线性表 L&#x3D;（a1,a2,…,an）用数组表示，假定删除表中任一元素的概率相同，则删除一个元素平均需要 移动元素的个数是**（n-1）&#x2F;2**。</p>
<p>123 .在单链表中设置头结点的作用是：<strong>头结点并不仅起标识作用，并使操作统一。另外，结点数据域可写入链表长度，或作监视哨，在第一个元素之前插入元素和删除第一个元素不必另作判断，另外，不论链表是否为空，链表指针不变</strong></p>
<p>124 .链接存储的特点是利用**（指针）**来表示数据元素之间的逻辑关系。</p>
<p>125 .顺序存储结构是通过**（物理上相邻）<strong>表示元素之间的关系的;链式存储结构是通过</strong>（指针）**表示元素之间的 关系的。</p>
<p>126 .对于双向链表,在两个结点之间插入一个新结点需修改的指针共 <strong>4</strong>个，单链表为<strong>2</strong>个。 </p>
<p>127 .循环单链表的最大优点是：（<strong>从任意节点出发都能访问到链表中的每一元素</strong>）。</p>
<p>128 . 带头结点的双循环链表 L 中只有一个元素结点的条件是：<strong>（L-&gt;next-&gt;next&#x3D;L）</strong></p>
<p>129 .如果有 n 个线性表同时并存，并且在处理过程中各表的长度会动态变化，线性表的总数也会自 动地改变。在此情况下，应选用哪种存储结构？ 为什么？ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//答：选链式存储结构，因为它可以动态申请内存空间，不受长度（即表中元素个数）的影响，插入删除时间复杂度为O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>130 .若线性表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取线性表中的元素， 那么应采用哪种存储结构？为什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选顺序存储结构，顺序表可以随机存储，时间复杂度为O（1）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>131 .线性表的顺序存储结构具有三个弱点：其一，在作插入或删除操作时，需移动大量元素；其二，由于难以估计，必须预先分配较大的空间，往往使存储空间不能得到充分利用；其三，表的容量难以扩充。线 性表的链式存储结构是否一定都能够克服上述三个弱点，试讨论之。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式存储结构一般说克服了顺序存储结构的三个弱点，</span></span><br><span class="line"><span class="comment">//首先，插入删除不需要移动元素，只需要移动指针。时间复杂度为O（1）</span></span><br><span class="line"><span class="comment">//其次，不需要预先分配空间，可根据需要动态申请空间</span></span><br><span class="line"><span class="comment">//其三，表容量只受可用内存空间的限制</span></span><br><span class="line"><span class="comment">//其缺点是因为指针增加了空间开销，当空间不允许时，就不能克服顺序存储缺点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>132 ．若较频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构？为什么？ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用链式存储结构，它根据实际需要申请内存空间，当不需要时又可以将不用空间返还给系统，在链式存储结构中插入和删除操作不需要移动元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>133 .线性结构包括<strong>线性表</strong>、<strong>栈</strong>、<strong>队列</strong>和<strong>串</strong>。线性表的存储结构分成<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p>
<p>134 . 说明在线性表的链式存储结构中，头指针与头结点之间的根本区别；头结点与首元结点的关系。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线性表的链式存储结构中，头指针指链表的指针，若链表有头结点则是链表的头结点的指针，头指针具有标识作用，故常用头指针冠以链表的名字。</span></span><br><span class="line"><span class="comment">//头结点是为了操作的统一、方便而设立的，放在第一元素结点之前，其数据域一般无意义（有些情况下也可以存放链表的长度，用作监视等等），有头结点之后，对在第一元素结点前插入结点和删除第一结点，其操作与对其它结点的操作统一了。而且无论链表是否为空，头指针均不为空。</span></span><br><span class="line"><span class="comment">//首元结点也就是第一元素结点，它是头结点后边的第一个结点。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>135 . 如何通过改链的方法，把一个单向链表变成一个与原来链接方向相反的单向链表？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表逆置</span></span><br><span class="line"><span class="comment">//将头结点摘下，并将其指针域置为空</span></span><br><span class="line"><span class="comment">//从第一元素结点开始，直到最后一个结点为止，依次前插入头结点的后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>136 . 若一个栈的输入序列为 1,2,3,…,n，输出序列的第一个元素是 i，则第 j 个输出元素是（ <strong>不确定的</strong>）。  若已知一个栈的入栈序列是 1,2,3,…,n，其输出序列为 p1,p2,p3，…，pN,若 pN是 n，则 pi是(  <strong>不确定的</strong>)。 </p>
<p>137 . 栈在**（ 递归调用、子程序调用、表达式求值）**中应用。</p>
<p> 138 。一个递归算法必须包括（ <strong>终止条件和递归部分</strong>）。</p>
<h2 id="139-中缀表达式计算、后缀表达式计算"><a href="#139-中缀表达式计算、后缀表达式计算" class="headerlink" title="139 .中缀表达式计算、后缀表达式计算"></a>139 .中缀表达式计算、后缀表达式计算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给一个中缀表达式，输出计算得到的值。</span><br><span class="line"><span class="number">7</span>*<span class="number">2</span>*<span class="number">2</span><span class="number">-5</span>+<span class="number">1</span><span class="number">-5</span>+<span class="number">3</span><span class="number">-4</span></span><br><span class="line">求解结果为<span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>设定两个栈s1和s2，s1用于存储运算对象，s2用于存储运算符。</span><br><span class="line"><span class="number">2.</span>从左到右扫描整个表达式，如果是运算对象，压入s1。</span><br><span class="line"><span class="number">3.</span>如果是运算符，则要分情况讨论：</span><br><span class="line">	<span class="number">1.</span>s2为空栈，直接压入栈中；</span><br><span class="line">	<span class="number">2.</span>当前运算符的优先级高于栈顶的优先级，压入栈</span><br><span class="line">	<span class="number">3.</span>当前运算符的优先级低于栈顶的优先级，s1出栈两个数据，s2出栈栈顶运算符，进行计算，结果压入s1。</span><br><span class="line">	<span class="number">4.</span>当前运算符还未入栈，继续循环第<span class="number">3</span>步骤（整个第<span class="number">3</span>步骤，不是里面的第<span class="number">3</span>步骤）。</span><br><span class="line">	<span class="number">5.</span>如果运算符为右括号，则持续出栈，直到s2中遇到左括号为止，然后去掉这一对括号。</span><br><span class="line">	<span class="number">5.</span>扫描完整个中缀表达式后，如果s2不为空，则依次从s1中出栈两个数据进行计算。结果压入栈中；循环往复，直到s2为空。最后s1中的数据就是所求的结果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>读字符</th>
<th>对象栈s1</th>
<th>算符栈s2</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>7</td>
<td>（</td>
<td>7入栈s1</td>
</tr>
<tr>
<td>*</td>
<td>7</td>
<td>（*</td>
<td>*入栈s2</td>
</tr>
<tr>
<td>2</td>
<td>7,2</td>
<td>(*</td>
<td>2入栈s1</td>
</tr>
<tr>
<td>*</td>
<td>14</td>
<td>(</td>
<td>做7*2&#x3D;14，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>14</td>
<td>(</td>
<td>*入栈s2</td>
</tr>
<tr>
<td>2</td>
<td>14,2</td>
<td>(*</td>
<td>2入栈s1</td>
</tr>
<tr>
<td>-</td>
<td>28</td>
<td>(*</td>
<td>做14*2&#x3D;28，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>28</td>
<td>(</td>
<td>-入栈s2</td>
</tr>
<tr>
<td>5</td>
<td>28,5</td>
<td>(-</td>
<td>5入栈s1</td>
</tr>
<tr>
<td>+</td>
<td>23</td>
<td>(-</td>
<td>做28-5&#x3D;23，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>23</td>
<td>(</td>
<td>+入栈s2</td>
</tr>
<tr>
<td>1</td>
<td>23,1</td>
<td>(+</td>
<td>1入栈s1</td>
</tr>
<tr>
<td>-</td>
<td>24</td>
<td>(+</td>
<td>做23+1&#x3D;24，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>24</td>
<td>(</td>
<td>-入栈s2</td>
</tr>
<tr>
<td>5</td>
<td>24,5</td>
<td>(-</td>
<td>5入栈s1</td>
</tr>
<tr>
<td>+</td>
<td>19</td>
<td>(</td>
<td>做24-5&#x3D;19，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>19</td>
<td>(+</td>
<td>+入栈s2</td>
</tr>
<tr>
<td>3</td>
<td>19,3</td>
<td>(+</td>
<td>3入栈s1</td>
</tr>
<tr>
<td>-</td>
<td>22</td>
<td>(</td>
<td>做19+3&#x3D;22，结果入栈s1</td>
</tr>
<tr>
<td></td>
<td>22</td>
<td>(-</td>
<td>-入栈s2</td>
</tr>
<tr>
<td>4</td>
<td>22,4</td>
<td>(-</td>
<td>4入栈s1</td>
</tr>
</tbody></table>
<p> <em><strong>扫描至表达式末尾，算符栈中还有算符，依次出栈，进行计算，所以22-4&#x3D;18。</strong></em> </p>
<p>后缀表达式求值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给一个后缀表达式，输出计算得到的值。</span><br><span class="line"><span class="number">32422</span>*+<span class="number">13</span>*-^*<span class="number">5</span>-</span><br><span class="line">求解结果为<span class="number">91</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用一个对象栈s1，来存储运算对象。</span><br><span class="line"><span class="number">2.</span>从左到右扫描表达式。</span><br><span class="line"><span class="number">3.</span>遇到运算对象，就入栈s1，遇到运算符，就从s1中取出两个运算对象，进行计算，结果压入s1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>读字符</th>
<th>对象栈s1</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>3</td>
<td>3入栈s1</td>
</tr>
<tr>
<td>2</td>
<td>3,2</td>
<td>2入栈s1</td>
</tr>
<tr>
<td>4</td>
<td>3,2,4</td>
<td>4入栈s1</td>
</tr>
<tr>
<td>2</td>
<td>3,2,4,2</td>
<td>2入栈s1</td>
</tr>
<tr>
<td>2</td>
<td>3,2,4,2,2</td>
<td>2入栈s1</td>
</tr>
<tr>
<td>*</td>
<td>3,2,4,4</td>
<td>计算2*2，将结果4入栈s1</td>
</tr>
<tr>
<td>+</td>
<td>3,2,8</td>
<td>计算4+4，将结果8入栈s1</td>
</tr>
<tr>
<td>1</td>
<td>3,2,8,1</td>
<td>1入栈s1</td>
</tr>
<tr>
<td>3</td>
<td>3,2,8,1,3</td>
<td>3入栈s1</td>
</tr>
<tr>
<td>*</td>
<td>3,2,8,3</td>
<td>计算1*3，将结果3入栈s1</td>
</tr>
<tr>
<td>-</td>
<td>3,2,5</td>
<td>计算8-3，将结果5入栈s1</td>
</tr>
<tr>
<td>^</td>
<td>3,32</td>
<td>计算2^5,将结果32入栈s1</td>
</tr>
<tr>
<td>*</td>
<td>96</td>
<td>计算3*32，将结果96入栈s1</td>
</tr>
<tr>
<td>5</td>
<td>96,5</td>
<td>5入栈s1</td>
</tr>
<tr>
<td>-</td>
<td>91</td>
<td>计算96-5，将结果91入栈s1</td>
</tr>
</tbody></table>
<p>表达式 3* 2^(4+2<em>2-6</em>3)-5 求值过程中当扫描到 6 时，对象栈和算符栈为（ <strong>D</strong>），其中^为乘幂 。  </p>
<p>A. 3,2,4,1,1；(<em>^(+</em>- B. 3,2,8；(<em>^- C. 3,2,4,2,2；(</em>^(- D. 3,2,8；(*^(-  </p>
<p>140 .设计一个判别表达式中左，右括号是否配对出现的算法，采用（ <strong>栈</strong>）数据结构最佳。 </p>
<p>141 . 用链接方式存储的队列，在进行删除运算时（<strong>D</strong> ）。</p>
<p>A. 仅修改头指针 B. 仅修改尾指针 C. 头、尾指针都要修改 D. 头、尾指针可能都要修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解析：链接方式存储队列的删除运算仍要保持链式队列结构。当队列中仅包含一个元素结点时，头尾指针均指向该结点，删除该结点后头尾指针均要修改；当队列中有多个结点时，队列的删除运算仅针对头结点，修改头指针即可。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![1700492311253](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1700492311253.png)</p>
<p>(进队尾指针++，出队头指针++)</p>
<p>142 .递归过程或函数调用时，处理参数及返回地址，要用一种称为（ <strong>栈</strong>）的数据结构。  </p>
<p>143  . 循环队列存储在数组 A[0..m]中，则入队时的操作为（ <strong>D</strong>）。</p>
<p>A. rear&#x3D;rear+1 B. rear&#x3D;(rear+1) mod (m-1)  </p>
<p> C. rear&#x3D;(rear+1) mod m D. rear&#x3D;(rear+1)mod(m+1) 144 .任何一个递归过程都可以转换成非递归过程。（ <strong>√</strong>）</p>
<p>144 . 栈是实现过程和函数等子程序所必需的结构。（ <strong>√</strong>） 只有那种使用了局部变量的递归过程在转换成非递归过程时才必须使用栈。（×） 通常使用队列来处理函数或过程的调用。（ ×）消除递归不一定需要使用栈（√）</p>
<p>145 . 循环队列通常用指针来实现队列的头尾相接。（ ×）</p>
<p>146 .栈是<strong>操作受限</strong>的线性表，其运算遵循_______的原则。</p>
<p>147 . 多个栈共存时，最好用<strong>链式存储结构</strong>作为存储结构。</p>
<p>148 . 循环队列的引入，目的是为了克服<strong>假溢出时大量移动数据元素</strong></p>
<p>149 .区分循环队列的满与空，只有两种方法，它们是<strong>牺牲一个存储单元</strong>和<strong>做标记</strong>。</p>
<p>150 .表达式求值是<strong>栈</strong>应用的一个典型例子。</p>
<p>151 .名词解释：栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈是只准在一端进行插入和删除操作的线性表，允许插入和删除的一端叫做栈顶，另一端叫做栈底。最后插入的元素最先删除，故也称为后进先出表</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>152 .名词解释：队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队列是只准在一端插入而另一端删除的线性表，允许插入的一段叫队尾，允许删除的一端叫队头。最先插入队的元素最先离开。故也称为先进先出表</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>153 .什么是循环队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用常规意义下顺序存储结构的一维数组表示队列，由于队列的性质，（队尾插入队头删除）容易造成“假溢出”现象，即队尾已达到一维数组的高下标，不能再插入，然而队中元素个数小于队列的长度（容量）。循环队列是解决“假溢出”的一种方法。通常把一维数组看成首尾相接，在循环队列下，通常采用“牺牲一个存储单元”或者“做标记”的方法解决队满和队空的判定问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="154-递归"><a href="#154-递归" class="headerlink" title="154 .递归"></a>154 .递归</h2><p>![1701269674529](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701269674529.png)</p>
<p>![1701269728991](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701269728991.png)</p>
<p>![1701269764311](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701269764311.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是递归？</span><br><span class="line">一个函数在结束本函数之前，直接或者间接调用函数自身，称为递归。</span><br><span class="line"><span class="number">2.</span>递归程序的优缺点是什么</span><br><span class="line">优点：程序结构简单，清晰，容易证明其正确性，</span><br><span class="line">缺点：执行中占内存空间较多，运行效率低</span><br><span class="line"><span class="number">3.</span>递归程序在执行时候，应该借助于什么来完成？   借助栈这种数据结构来实现</span><br><span class="line"><span class="number">4.</span>递归程序的入口语句、出口语句一般用什么语句来实现</span><br><span class="line">递归程序的入口语句和出口语句一般用条件语句来实现，递归程序由基本项和归纳项组成。基本项时递归程序出口，即不再递归即可求出结果的部分，归纳项时将原来问题化成简单的且与原来形式一样的问题，即向着基本项发展，最终到达基本项    </span><br></pre></td></tr></table></figure>

<p>递归和栈</p>
<p>![1701269997526](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701269997526.png)</p>
<p>![1701270056788](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701270056788.png)</p>
<p>![1701270093552](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701270093552.png)</p>
<p>递归算法的时间复杂度分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Hanoi1</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> X,<span class="type">char</span> Y,<span class="type">char</span> Z)</span></span><br><span class="line">&#123;  <span class="keyword">if</span> (n==<span class="number">1</span>) 			<span class="comment">//只有一个盘片的情况</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;	将第%d个盘片从%c移动到%c</span></span><br><span class="line"><span class="string">&quot;</span>,n,X,Z);</span><br><span class="line">   <span class="keyword">else</span>				<span class="comment">//有两个或多个盘片的情况</span></span><br><span class="line">   &#123;  Hanoi1(n<span class="number">-1</span>,X,Z,Y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;	将第%d个盘片从%c移动到%c</span></span><br><span class="line"><span class="string">&quot;</span>,n,X,Z);</span><br><span class="line">      Hanoi1(n<span class="number">-1</span>,Y,X,Z);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求Hanoi1(n，x，y，z)的时间复杂度。</span></span><br><span class="line"><span class="comment">//设Hanoi1(n，x，y，z)的执行时间为T(n)。</span></span><br><span class="line"><span class="comment">//则两个问题规模为n-1的子问题的执行时间均为T(n-1)。</span></span><br><span class="line"><span class="comment">//总执行时间是累加关系。</span></span><br><span class="line"><span class="comment">//递推式如下。</span></span><br><span class="line">T(n)=<span class="number">1</span>				    当n=<span class="number">1</span>时</span><br><span class="line">T(n)=<span class="number">2</span>T(n<span class="number">-1</span>)+<span class="number">1</span>			当n&gt;<span class="number">1</span>时</span><br><span class="line">T(n) = <span class="number">2</span>T(n<span class="number">-1</span>)+<span class="number">1</span> = <span class="number">2</span>(<span class="number">2</span>T(n<span class="number">-2</span>)+<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">     = <span class="number">22</span>T(n<span class="number">-2</span>)+<span class="number">2</span>+<span class="number">1</span> = <span class="number">22</span>(<span class="number">2</span>T(n<span class="number">-3</span>)+<span class="number">1</span>)+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">     = <span class="number">23</span>T(n<span class="number">-3</span>)+<span class="number">22</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">     = …</span><br><span class="line">     = <span class="number">2</span>n<span class="number">-1</span>T(<span class="number">1</span>)+<span class="number">2</span>n<span class="number">-2</span>+ … +<span class="number">22</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">     = <span class="number">2</span>n<span class="number">-1</span></span><br><span class="line">     = O(<span class="number">2</span>n)。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//例二</span></span><br><span class="line"><span class="type">void</span> fun(<span class="type">int</span> a[]，<span class="type">int</span> n，<span class="type">int</span> k)  </span><br><span class="line">&#123;  <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (k==n<span class="number">-1</span>)</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) 　　  </span><br><span class="line">	 <span class="built_in">printf</span>(“%d</span><br><span class="line">”，a[i]);	  <span class="comment">//执行n次</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;  <span class="keyword">for</span> (i=k;i&lt;n;i++)　   </span><br><span class="line">	  a[i]=a[i]+i*i;	          <span class="comment">//执行n-k次</span></span><br><span class="line">      fun(a，n，k+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;    </span><br><span class="line">T1(n，k) = n    		      		当k=n<span class="number">-1</span>时</span><br><span class="line">T1(n，k) = (n-k)+T1(n，k+<span class="number">1</span>)      	当k&lt;n<span class="number">-1</span>时 </span><br><span class="line">设fun(a，n，<span class="number">0</span>)的执行时间为T(n)</span><br><span class="line">而fun(a，n，k)的执行时间为T1(n，k)</span><br><span class="line">T(n) = T1(n，<span class="number">0</span>) = n + T1(n，<span class="number">1</span>) = n + (n<span class="number">-1</span>) + T1(n，<span class="number">2</span>)</span><br><span class="line">　     = … = n+(n<span class="number">-1</span>) + … + <span class="number">2</span>+T1(n，n<span class="number">-1</span>)</span><br><span class="line">     　= n + (n<span class="number">-1</span>) + … + <span class="number">2</span> + n</span><br><span class="line">　     = n(n+<span class="number">1</span>)/<span class="number">2</span>+n<span class="number">-1</span></span><br><span class="line">       = O(n2)</span><br><span class="line">所以调用fun(a，n，<span class="number">0</span>)的时间复杂度为O(n2)。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>用递归计算单链表长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Count</span><span class="params">(LinkNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Count(p-&gt;next)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用递归算法正向输出单链表中L的所有结点值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(LinkNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(L!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,L-&gt;data);</span><br><span class="line">        traverse(L-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>155 .下面关于串的的叙述中，哪一个是不正确的？（ <strong>B</strong>）A．串是字符的有限序列 B．空串是由空格构成的串  C．模式匹配是串的一种重要运算 D．串既可以采用顺序存储，也可以采用链式存储 </p>
<p>156 .计算子串数：n*(n+1)&#x2F;2+1</p>
<p>157 .．KMP 算法的特点是在模式匹配时指示主串的指针不会变小。（ √）</p>
<p>158 .设模式串的长度为 m,目标串的长度为 n，当 n≈m 且处理只匹配一次的模式时，朴素的匹配（即子串定位函数）算法所花的时间代价可能会更为节省。（√ ）</p>
<p>159 .串是一种数据对象和操作都特殊的线性表。（ √）</p>
<p>160 .空格串是指（由空格字符组成的字符串），其长度等于（空格个数）</p>
<p>161 .组成串的数据元素只能是（字符）</p>
<p>162 .一个字符串中（任意个连续的字符组成的子序列）称为该串的子串</p>
<p>163 .设正文串长度为n,模式串长度为m，则串匹配的KMP算法的时间复杂度为（<strong>O（m+n）</strong>）</p>
<p>164 .设T和P是连个给定的串，在T中寻找等于P的子串的过程称为（模式匹配），又称P为（模式串）</p>
<p>165 .特殊线性表串的特殊性表现在其<strong>数据元素都是字符</strong>，其最基本的存储方式是（顺序存储和链式存储），两个串相等的充分必要条件是（串的长度相等且两串中对应位置的字符也相等）</p>
<p>166 。名词解释，串：串是零个至多个字符构成的有限序列。从数据结构的角度讲，串属于线性结构。与线性表的特殊性在于串的元素是字符</p>
<p>167 .描述以下概念的区别（空格串和空串）：空格是一个字符，其ASCII码是32，空格串是由空格组成的串，其长度等于空格的个数。空串是不含任何字符的串，即空串的长度为0.</p>
<p>168 .两个字符串s1和s2的长度分别是m和n，求这两个字符串最大共同子串算法的时间复杂度为T(m,n)；估算最优的T(m,n)，并且说明理由：串s2是串s1的子串，且在s1中的位置是1,开始求出最大公共子串的长度恰好是s2的长度n.但是一般情况下时间复杂度为m*n</p>
<p>169 . 对稀疏矩阵进行压缩存储目的是（ 节省存储空间）。</p>
<h2 id="170-广义表head与tail"><a href="#170-广义表head与tail" class="headerlink" title="170 .广义表head与tail"></a>170 .广义表head与tail</h2><p>![1701267587153](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267587153.png)</p>
<p>根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。<br>也就是说，广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“ （）“</p>
<p>举一个简单的列子：已知广义表LS&#x3D;((a,b,c),(d,e,f)),如果需要取出这个e这个元素，那么使用tail和head如何将这个取出来。</p>
<p>利用上面说的，tail取出来的始终是一个表，即使只有一个简单的一个元素，tail取出来的也是一个表，而head取出来的可以是一个元素也可以是一个表。<br>解：</p>
<p>tail(LS) &#x3D; ((d,e,f))</p>
<p>head(tail(LS)) &#x3D; (d,e,f)</p>
<p>tail(head(tail(LS))) &#x3D; (e,f)&#x2F;&#x2F;无论如何都会加上这个()括号</p>
<p>head(tail(head(tail(LS)))) &#x3D; e&#x2F;&#x2F;head可以去除单个元素<br>171 .数组不适合作为任何二叉树的存储结构。（ ×）</p>
<p>172 . 从逻辑结构上看，n 维数组的每个元素均属于 n 个向量。（√）</p>
<p>173 . 稀疏矩阵压缩存储后，必会失去随机存取功能。（ √）</p>
<p>174 . 数组是同类型值的集合。（ ×）</p>
<p>175 .数组可看成线性结构的一种推广，因此与线性表一样，可以对它进行插入，删除等操作。（ ×） </p>
<p>176 . 二维以上的数组其实是一种特殊的广义表。（ √） </p>
<p>177 . 若一个广义表的表头为空表，则此广义表亦为空表。（ ×） </p>
<p>178 .广义表中的元素或者是一个不可分割的原子，或者是一个非空的广义表。</p>
<p>（× ） </p>
<p>179 .所谓取广义表的表尾就是返回广义表中最后一个元素。（ ×）</p>
<p>180  . 广义表的同级元素（直属于同一个表中的各元素）具有线性关系。（× ） </p>
<p>181 . 一个广义表可以为其它广义表所共享。（√ ）</p>
<h2 id="182-对角矩阵"><a href="#182-对角矩阵" class="headerlink" title="182 .对角矩阵"></a>182 .对角矩阵</h2><p>![1701267043178](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267043178.png)</p>
<p>![1701267116156](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267116156.png)</p>
<h2 id="183-稀疏矩阵"><a href="#183-稀疏矩阵" class="headerlink" title="183 .稀疏矩阵"></a>183 .稀疏矩阵</h2><p>![1701267361332](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701267361332.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize  100  	<span class="comment">//矩阵中非零元素最多个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>  <span class="type">int</span> r;            		<span class="comment">//行号</span></span><br><span class="line">   <span class="type">int</span> c;            		<span class="comment">//列号</span></span><br><span class="line">   ElemType d;     		<span class="comment">//元素值</span></span><br><span class="line">&#125; TupNode;          		<span class="comment">//三元组定义  ,存放一个非零元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>  <span class="type">int</span> rows;          	<span class="comment">//行数值</span></span><br><span class="line">   <span class="type">int</span> cols;          	<span class="comment">//列数值</span></span><br><span class="line">   <span class="type">int</span> nums;          	<span class="comment">//非零元素个数</span></span><br><span class="line">   TupNode data[MaxSize];</span><br><span class="line">&#125; TSMatrix;           	<span class="comment">//三元组顺序表定义，存放整个稀疏矩阵</span></span><br></pre></td></tr></table></figure>

<p>稀疏矩阵的十字链表表示</p>
<p> <img src="https://pic4.zhimg.com/v2-4fe6c4db574d58c223ac1c5aba6c283b_b.webp" alt="动图"> </p>
<p> <img src="https://pic2.zhimg.com/v2-9c227393dcc7d55b5e4c5b2d65932b0d_b.jpg" alt="动图封面"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200324222509461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200324222623938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p>将同一行所有结点构成一个带头结点的循环单链表</p>
<p>将同一列所有结点构成一个带头结点的循环单链表</p>
<p>将行头结点和列头结点结合起来，一个头结点内既包含行指针又包含列指针</p>
<p>再将所有头结点连起来构成一个带总头结点的循环单链表</p>
<p>所以存储一个有k个非零元素的m*n稀疏矩阵的总结点数为MAX(m,n)+k+1</p>
<h2 id="184-第七章：树"><a href="#184-第七章：树" class="headerlink" title="184 .第七章：树"></a>184 .第七章：树</h2><p>1.树是由n个结点组成的有限集合。</p>
<p>如果n&#x3D;0，它是空树</p>
<p>如果n&gt;0,则这n个结点有且仅有一个结点作为树的根节点</p>
<p>每个子集称为根节点的子树</p>
<p>![1701489466871](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489466871.png)</p>
<p>![1701489414365](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489414365.png)</p>
<p>2 .树的逻辑表示方法</p>
<p>![](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489557243.png)</p>
<p>![1701489546996](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489546996.png)</p>
<p>![1701489674539](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489674539.png)</p>
<p>![1701489707766](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489707766.png)</p>
<p>3 .树的基本术语</p>
<p>3.1 结点的度：树中一个结点的子树的个数称为该结点的度</p>
<p>3.2 树的度 ：树中各节点的度的最大值称为数的度，通常将度为m的树称为m叉树![1701489921043](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701489921043.png)</p>
<p>3.3 分支结点 ：度不为0的结点称为非终端结点，也叫分支结点（根结点也是分支结点）</p>
<p>3.4 叶结点：度为0的结点称为终端节点或叶结点或叶子结点</p>
<p>3.5 单分支结点：度为1的结点</p>
<p>3.6 双分支结点：度为2的结点</p>
<p>3.7 路径：两个结点di和dj的结点序列称为路径</p>
<p>3.8 路径长度：路径长度等于路径所通过的结点数目减一（即路径上的分支数目）</p>
<p>![1701490389454](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490389454.png)</p>
<p>3.9 孩子结点：每个结点的后继称为这个结点的孩子结点</p>
<p>3.10 双亲结点：每个结点的前驱称为这个结点的孩子结点</p>
<p>3.11 兄弟结点：具有同一双亲的孩子结点互为兄弟节点</p>
<p>![1701490490481](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490490481.png)</p>
<p>3.12 子孙节点：一个节点的所有子树中的节点称为该节点的子孙节点</p>
<p>3.13 祖先结点 ：从根结点到达一个结点的路径上经过的所有结点称为该结点的祖先结点</p>
<p>![1701490607020](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490607020.png)</p>
<p>3.14 结点的层次：每个结点都处在一个层次，根节点为第一层，它的孩子结点为第二层，一个结点所在层次为其双亲结点所在的层次加1</p>
<p>3.15 树的高度（深度）：树中的最大层次</p>
<p>![1701490746039](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490746039.png)</p>
<p>3.15 有序树、无序树：若树中各个结点的子树是按照一定层次从左向右安排的，且相对次序不能随意变换，称为有序树，否则是无序树</p>
<p>![1701490857045](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490857045.png)</p>
<p>3.16 森林：n个互不相交的树的集合（把含有多颗子树的根结点删掉就成了森林）</p>
<p>![](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701490952408.png)</p>
<p>4 .树的性质</p>
<p>4.1 树中的结点数等于所有结点的度数之和+1(1指代的是根结点)</p>
<p>![](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701491217582.png)</p>
<p>4.2 实际分支数&#x3D;结点数-1&#x3D;度之和</p>
<p>4.3 度为m的树表示结点数n&#x3D;n0+n1+……+nm.（ni为度为i的结点的个数）</p>
<p>![1701491399374](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701491399374.png)</p>
<p>4.4 度为m的树表示结点数n-1&#x3D;1n1+2n2+3n3……+mnm.（ni为度为i的结点的个数）</p>
<p>![1701491519489](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701491519489.png)</p>
<p>4.5 度为m的树中第i层上最多有m^(i-1)个结点</p>
<p>![1701491864832](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701491864832.png)</p>
<p>4.6 高度为h的m次树至多有(m^h-1)&#x2F;(m-1)个结点</p>
<p>![1701491955734](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701491955734.png)</p>
<p>4.7 具有n个结点的m次树的最小高度为![1701492089357](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492089357.png)</p>
<p>![1701492106135](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492106135.png)</p>
<p>4.8 具有n个结点的m次树的最大高度为n-(m-1)</p>
<p>![1701492208423](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492208423.png)</p>
<p>5.树的基本运算：查找、插入或删除、遍历</p>
<p>![](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492338736.png)</p>
<p>5.1遍历</p>
<p>![1701492405878](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492405878.png)</p>
<p>![1701492636114](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492636114.png)</p>
<p>![1701492746861](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492746861.png)</p>
<p>![1701492773272](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492773272.png)</p>
<p>6.树的存储结构</p>
<p>6.1 双亲存储结构</p>
<p>![1701492925854](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492925854.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲存储结构的类型声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;	<span class="comment">//结点的值</span></span><br><span class="line">   <span class="type">int</span> parent;		<span class="comment">//指向双亲的位置</span></span><br><span class="line">&#125; PTree[MaxSize];</span><br></pre></td></tr></table></figure>

<p>6.2 孩子链存储结构</p>
<p>![1701492997553](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701492997553.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//孩子链存储结构类型声明，其中，Maxsons为最多的孩子结点个数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;		      	<span class="comment">//结点的值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">sons</span>[<span class="title">MaxSons</span>];</span>	<span class="comment">//指向孩子结点</span></span><br><span class="line">&#125; TSonNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![1701493135723](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701493135723.png)</p>
<p>以孩子链作为树的存储结构，设计一个求树t高度的递归算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(t)=0  如果t=NULL</span></span><br><span class="line"><span class="comment">//f(t)=MAX&#123;f(p)&#125;+1  其他情况（p指向t的孩子）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeHeight1</span><span class="params">(TSonNode *t)</span></span><br><span class="line">&#123;  TSonNode *p;</span><br><span class="line">   <span class="type">int</span> i,h,maxh=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//空树返回高度0</span></span><br><span class="line">   <span class="keyword">else</span>					<span class="comment">//处理非空树</span></span><br><span class="line">   &#123;  <span class="keyword">for</span>（i=<span class="number">0</span>;i&lt;MaxSons;i++)</span><br><span class="line">      &#123;  p=t-&gt;sons[i];		<span class="comment">//p指向t的第i+1个孩子结点</span></span><br><span class="line">         <span class="keyword">if</span> (p!=<span class="literal">NULL</span>)			<span class="comment">//若存在第i+1个孩子</span></span><br><span class="line">	  &#123;  h=TreeHeight1(p);	<span class="comment">//求出对应子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (maxh&lt;h) maxh=h;	<span class="comment">//求所有子树的最大高度</span></span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>(maxh+<span class="number">1</span>);			<span class="comment">//返回maxh+1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.3 孩子兄弟链式存储结构</p>
<p>![1701497484864](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701497484864.png)</p>
<p>![1701497513344](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701497513344.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> </span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;		<span class="comment">//结点的值</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">hp</span>;</span>  	<span class="comment">//指向右侧第1个个兄弟（水平方向h）</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">vp</span>;</span>  	<span class="comment">//指向第1个孩子结点（垂直方向v）</span></span><br><span class="line">&#125; TSBNode;</span><br></pre></td></tr></table></figure>

<p>![1701497576935](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701497576935.png)</p>
<p>以孩子兄弟链式存储作为树的存储结构，设计求树t高度的递归算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(t)=0  如果t=NULL</span></span><br><span class="line"><span class="comment">//f(t)=MAX &#123;f(p)&#125;+1  其他情况（p指向t的孩子）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeHeight2</span><span class="params">(TSBNode *t)</span></span><br><span class="line">&#123;  TSBNode *p;</span><br><span class="line">   <span class="type">int</span> h,maxh=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//空树返回0</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;  p=t-&gt;vp;				<span class="comment">//指向第1个孩子结点</span></span><br><span class="line">      <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)			<span class="comment">//扫描t的所有子树</span></span><br><span class="line">      &#123;  h=TreeHeight2(p);		<span class="comment">//求出p子树的高度</span></span><br><span class="line">         <span class="keyword">if</span> (maxh&lt;h) maxh=h;		<span class="comment">//求所有子树的最大高度</span></span><br><span class="line">         p=p-&gt;hp;			<span class="comment">//继续处理t的其他子树</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>(maxh+<span class="number">1</span>);			<span class="comment">//返回maxh+1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="185-第七章：二叉树"><a href="#185-第七章：二叉树" class="headerlink" title="185 .第七章：二叉树"></a>185 .第七章：二叉树</h2><p>1.定义：二叉树包括左子树和右子树和一个根结点</p>
<p>![1701498274721](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701498274721.png)</p>
<p>2.表示方法</p>
<p>![1701498307728](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701498307728.png)</p>
<p>![1701498373543](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701498373543.png)</p>
<p>3.两种特殊的二叉树</p>
<p>3.1、满二叉树</p>
<p>![1701604140447](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701604140447.png)</p>
<p>满二叉树内![1701604174777](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701604174777.png)</p>
<p>3.2、完全二叉树</p>
<p>![1701604295713](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701604295713.png)</p>
<p>4 .二叉树性质</p>
<p>4.1 非空二叉树上叶结点数等于双分支结点数+1，![1701604470501](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701604470501.png)</p>
<p>![1701604588358](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701604588358.png)</p>
<p>求解一般二叉树结点个数方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=n0+n1+n2</span><br><span class="line">度之和=n<span class="number">-1</span></span><br><span class="line">度之和=n<span class="number">-1</span>=n1+<span class="number">2</span>n2</span><br><span class="line">--&gt;&gt;n=n1+<span class="number">2</span>n2+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    利用二叉树的性质：n0=n2+<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>4.2 非空二叉树上第i层上至多有2^(i-1)个结点（i&gt;&#x3D;1）</p>
<p>4.3 高度为i的 二叉树至多有2^i-1个结点</p>
<p>4.4 完全二叉树（含n个结点）n1&#x3D;0或者n1&#x3D;1</p>
<p>4.5 完全二叉树（含n个结点）若满足（2i&lt;&#x3D;n）则编号为i的结点为分支结点，否则为叶子结点。</p>
<p>4.6 完全二叉树（含n个结点）若n为奇数，则每个分支结点都既有左孩子结点，又有右孩子结点</p>
<p>4.7 完全二叉树（含n个结点）若n为偶数，则编号最大的分支结点只有左孩子结点，没有右孩子结点。其他分支结点两者都有</p>
<p>4.8完全二叉树（含n个结点）。编号为i的结点的左孩子结点编号为2i，右孩子结点的编号为2i+1</p>
<p>4.9 完全二叉树（含n个结点）。编号为i的结点的双亲结点编号为【i&#x2F;2】(向下取整)（除了根结点）</p>
<p>4.10 完全二叉树（含n个结点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n0=n2+<span class="number">1</span></span><br><span class="line">n1=<span class="number">0</span>(n为奇数)，n1=<span class="number">1</span>(n为偶数)</span><br><span class="line">n2=(n-n1<span class="number">-1</span>)/<span class="number">2</span>=n0<span class="number">-1</span></span><br><span class="line">n =n0+n1+n2=<span class="number">2</span>n2+n1+<span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>![1701607318694](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701607318694.png)</p>
<p>5 二叉树与树、森林之间的转换（唯一对换）</p>
<p>![1701608382593](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608382593.png)</p>
<p>![1701608433641](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608433641.png)</p>
<p>![1701608523825](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608523825.png)</p>
<p>![1701608581365](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608581365.png)</p>
<p>![1701608603975](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608603975.png)</p>
<p>6.二叉树的存储结构</p>
<p>6.1 二叉树的顺序存储结构</p>
<p>![1701608791133](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608791133.png)</p>
<p>![1701608815002](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608815002.png)</p>
<p>![1701608881370](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701608881370.png)</p>
<p>二叉树顺序存储结构的特点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对于完全二叉树来说，其顺序存储是十分合适的</span><br><span class="line"><span class="number">2.</span>对于一般的二叉树，特别是对于那些单分支结点较多的二叉树来说是很不合适的，因为可能只有少数存储单元被利用，特别是对退化的二叉树（即每个分支结点都是单分支的，空间浪费的惊人）</span><br><span class="line"><span class="number">3.</span>在顺序存储结构中，找一个结点的双亲和孩子都很容易</span><br></pre></td></tr></table></figure>

<p>6.2 二叉树的链式存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span>  ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>， *<span class="title">rchild</span>;</span><span class="comment">//指向的都是二叉树，（递归性）</span></span><br><span class="line">&#125; BTNode; </span><br></pre></td></tr></table></figure>

<p>![1701609253321](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701609253321.png)</p>
<p>二叉链存储结构的特点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>除了指针外，二叉链比较洁身存储空间，占用的存储空间与树形没有关系，只与树种结点个数有关。</span><br><span class="line"><span class="number">2.</span>在二叉链中，找一个结点的孩子很容易，但找其双亲不方便    </span><br></pre></td></tr></table></figure>

<p>在二叉链中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n个结点-&gt;<span class="number">2</span>n个指针域</span><br><span class="line">分支数为n<span class="number">-1</span>,非空指针域有n<span class="number">-1</span>个</span><br><span class="line">空指针域个数=<span class="number">2</span>n-(n<span class="number">-1</span>)=n+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>186 .环形队列一定优于非环形队列吗，在甚么情况下使用非环形队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解：队列用于保存中间数据，其数据具有先产生先处理的特点，非环形队列具有数据假溢出现象。为此改成环形队列克服了假溢出现象。但环形队列中出队元素的空间可能被后进队元素覆盖，若算法要求在队列操作结束后利用进队元素实现某项功能，则此时要把环形队列改成非环形队列</span></span><br></pre></td></tr></table></figure>

<p>甚么是环形队列，采用甚么方法实现环形队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在用数组表示队列的时候把数组看成一个环形的，即令数组的第一个元素紧跟在最后一个单元后面形成环形队列，环形队列解决了非环形队列中出现的“假溢出”现象。</span></span><br></pre></td></tr></table></figure>

<p>多个顺序存储空间建立多个独立的顺序栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优点是每个栈仅用一个顺序存储空间时操作简单，缺点是各栈的初始空间分配小了容易产生溢出，分配空间大了容易造成浪费，各栈不能共享空间。</span></span><br></pre></td></tr></table></figure>

<p>多个栈共享一个顺序存储空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储空间只有在整个存储空间都用完时才会出现溢出，缺点是当一个栈满时要向左右查询空闲单元，移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时</span></span><br></pre></td></tr></table></figure>

<p>分别建立多个独立的链栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优点是多个链栈一般不考虑栈的溢出，缺点是链栈中元素要以指针相链接，存储密度较低</span></span><br></pre></td></tr></table></figure>

<p>187 .简述线性表的两种存储结构的主要特点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//答：线性表的两种存储结构分别是顺序存储结构和链式存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序存储结构特点</span></span><br><span class="line"><span class="comment">//1.数据元素中只有自身的数据域，没有关联指针域，存储密度大</span></span><br><span class="line"><span class="comment">//2.数据存储结构需要分配一整块比较大的存储空间，所以存储空间利用率低</span></span><br><span class="line"><span class="comment">//3.逻辑相邻的两个元素在物理上也相邻，通过元素的逻辑序号可以直接获取其元素值，具有随机存储特性</span></span><br><span class="line"><span class="comment">//4.插入和删除操作会引起大量元素移动。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式存储结构特点</span></span><br><span class="line"><span class="comment">//1.数据结点内除了自身的数据域外还有表示逻辑关系的指针域，因此链式存储结构比顺序存储结构存储密度小</span></span><br><span class="line"><span class="comment">//2.链式存储结构的每个结点是单独分配的，每个存储空间相对较小，存储空间利用率高</span></span><br><span class="line"><span class="comment">//3.在逻辑上相邻的结点在物理上不一定相邻，因此不具备随机存储特性</span></span><br><span class="line"><span class="comment">//4.插入和删除操作方便，灵活不必移动结点，只需要修改指针域</span></span><br></pre></td></tr></table></figure>

<p>188 .简述引用运算符的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立引用时，程序用另一个已定义变量的名字初始化它，引用变量作为目标变量的别名使用，对引用变量的改动实际为目标变量的改动</span></span><br></pre></td></tr></table></figure>

<p>189 .数据结构和类型有什么不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.结构是指数据元素以及数据元素之间的关系</span></span><br><span class="line"><span class="comment">//2.类型是一组相同性质的值的集合和定义在此集合上一操作的总称</span></span><br></pre></td></tr></table></figure>

<p>190 .简述描述和运算之间的不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//描述是对抽象的、运算功能的描述，基于逻辑结构的，实现是完成运算的实现算法，具体的，基于存储结构的</span></span><br></pre></td></tr></table></figure>

<p>191 .数据逻辑结构与存储结构的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑结构与存储结构无关</span></span><br><span class="line"><span class="comment">//存储结构是数据元素之间的逻辑关系在计算机中的表示，存储各数据元素之间的逻辑关系</span></span><br></pre></td></tr></table></figure>

<p>192 .将两个各有n个元素的递增有序顺序表归并成一个有序顺序表，其最少的元素比较次数是<strong>n</strong>,将两个长度分别为n,m的递增有序顺序表归并成一个有序顺序表，其元素最多的比较次数是<strong>m+n-1</strong></p>
<p>193 .线性表（含n个元素）的基本运算之一是删除第i个元素，其中i的有效取值范围是0≤i≤n-1。(×)（基本运算中元素序号，是指逻辑序号，从1开始，这里i的有效值范围是1&lt;&#x3D;i&lt;&#x3D;n）</p>
<h2 id="194-特殊矩阵"><a href="#194-特殊矩阵" class="headerlink" title="194 .特殊矩阵"></a>194 .特殊矩阵</h2><p>1 .对称矩阵（行序存储）</p>
<p>![1701699739319](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701699739319.png)</p>
<p>![1701699774997](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701699774997.png)</p>
<p>2 .上三角矩阵（行序存储）</p>
<p>![1701700150107](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701700150107.png) </p>
<p>3.对角矩阵</p>
<p>![1701700266892](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701700266892.png)</p>
<p>4.三对角矩阵</p>
<p>![1701700327011](C:\Users\86177\AppData\Roaming\Typora	ypora-user-images\1701700327011.png)</p>
<!-- flag of hidden posts -->
      
    </div>
    
  </div>
  
    
  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 shenle
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>